# CloudDemo 业务功能扩展方案

## 🎯 扩展目标

在现有CloudDemo微服务基础上，增加更丰富的业务功能模块，提升项目的业务完整性和技术深度：

- **商品管理模块**: 商品信息、库存管理、价格策略
- **购物车功能**: 购物车操作、商品收藏、优惠券
- **支付系统**: 多种支付方式、支付流程、退款处理
- **库存服务**: 实时库存、预扣库存、库存回滚
- **促销活动**: 秒杀活动、优惠券、积分系统
- **消息通知**: 站内消息、邮件通知、短信验证

## 🛍️ 商品管理模块

### 服务架构设计

#### 1. 商品服务 (product-service:8001)

```java
@RestController
@RequestMapping("/products")
@Tag(name = "商品管理API", description = "商品信息的增删改查操作")
public class ProductController {
    
    @GetMapping("/category/{categoryId}")
    @Operation(summary = "按分类查询商品")
    public ResponseEntity<List<Product>> getProductsByCategory(
            @PathVariable Long categoryId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        // 分页查询商品列表
    }
    
    @PostMapping
    @Operation(summary = "创建商品")
    public ResponseEntity<Product> createProduct(
            @Valid @RequestBody CreateProductRequest request) {
        // 商品创建逻辑
    }
    
    @PutMapping("/{id}/stock")
    @Operation(summary = "更新商品库存")
    public ResponseEntity<Void> updateStock(
            @PathVariable Long id,
            @RequestBody UpdateStockRequest request) {
        // 库存更新逻辑
    }
}
```

#### 2. 商品实体设计

```java
@Entity
@Table(name = "products")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String name;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal originalPrice;
    
    @Column(nullable = false)
    private Integer stock;
    
    @Column(nullable = false)
    private Integer soldCount = 0;
    
    @Enumerated(EnumType.STRING)
    private ProductStatus status = ProductStatus.ACTIVE;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;
    
    @Column(length = 500)
    private String imageUrl;
    
    @ElementCollection
    @CollectionTable(name = "product_images")
    private List<String> images = new ArrayList<>();
    
    @ElementCollection
    @MapKeyColumn(name = "spec_name")
    @Column(name = "spec_value")
    @CollectionTable(name = "product_specifications")
    private Map<String, String> specifications = new HashMap<>();
    
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}

@Entity
@Table(name = "categories")
@Data
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(length = 500)
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private Category parent;
    
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<Category> children = new ArrayList<>();
    
    private Integer sortOrder = 0;
    private Boolean enabled = true;
}

public enum ProductStatus {
    ACTIVE,     // 上架
    INACTIVE,   // 下架
    OUT_OF_STOCK, // 缺货
    DISCONTINUED  // 停产
}
```

### 库存管理策略

#### 1. 实时库存服务

```java
@Service
@Slf4j
public class InventoryService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductMapper productMapper;
    
    private static final String STOCK_KEY_PREFIX = "product:stock:";
    private static final String RESERVED_KEY_PREFIX = "product:reserved:";
    
    /**
     * 预扣库存 - 用于下单时锁定库存
     */
    @Transactional
    public boolean reserveStock(Long productId, Integer quantity) {
        String stockKey = STOCK_KEY_PREFIX + productId;
        String reservedKey = RESERVED_KEY_PREFIX + productId;
        
        // 使用Lua脚本保证原子性
        String luaScript = """
            local stockKey = KEYS[1]
            local reservedKey = KEYS[2]
            local quantity = tonumber(ARGV[1])
            
            local currentStock = tonumber(redis.call('GET', stockKey) or 0)
            local currentReserved = tonumber(redis.call('GET', reservedKey) or 0)
            
            if currentStock >= quantity then
                redis.call('DECRBY', stockKey, quantity)
                redis.call('INCRBY', reservedKey, quantity)
                return 1
            else
                return 0
            end
            """;
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(luaScript);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Arrays.asList(stockKey, reservedKey), 
            quantity);
        
        return result != null && result == 1;
    }
    
    /**
     * 确认扣减库存 - 支付成功后确认扣减
     */
    @Transactional
    public void confirmStock(Long productId, Integer quantity) {
        String reservedKey = RESERVED_KEY_PREFIX + productId;
        redisTemplate.opsForValue().decrement(reservedKey, quantity);
        
        // 异步更新数据库库存
        updateDatabaseStock(productId, quantity);
    }
    
    /**
     * 释放库存 - 订单取消时释放预扣的库存
     */
    public void releaseStock(Long productId, Integer quantity) {
        String stockKey = STOCK_KEY_PREFIX + productId;
        String reservedKey = RESERVED_KEY_PREFIX + productId;
        
        redisTemplate.opsForValue().increment(stockKey, quantity);
        redisTemplate.opsForValue().decrement(reservedKey, quantity);
    }
    
    @Async
    private void updateDatabaseStock(Long productId, Integer quantity) {
        productMapper.decreaseStock(productId, quantity);
        log.info("数据库库存已更新，商品ID: {}, 扣减数量: {}", productId, quantity);
    }
}
```

## 🛒 购物车功能

### 购物车服务设计

#### 1. 购物车实体

```java
@Entity
@Table(name = "shopping_carts")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingCart {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false)
    private Long productId;
    
    @Column(nullable = false)
    private Integer quantity;
    
    @Column(nullable = false)
    private Boolean selected = true;
    
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    
    // 冗余商品信息，提高查询性能
    @Transient
    private Product product;
}

@Entity
@Table(name = "user_favorites")
@Data
public class UserFavorite {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false)
    private Long productId;
    
    private LocalDateTime createTime;
}
```

#### 2. 购物车操作接口

```java
@RestController
@RequestMapping("/cart")
@Tag(name = "购物车API")
public class ShoppingCartController {
    
    @PostMapping("/add")
    @Operation(summary = "添加商品到购物车")
    public ResponseEntity<ApiResponse<Void>> addToCart(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody AddToCartRequest request) {
        
        Long userId = jwtUtil.getUserIdFromToken(token);
        cartService.addToCart(userId, request.getProductId(), request.getQuantity());
        
        return ResponseEntity.ok(ApiResponse.success("商品已添加到购物车"));
    }
    
    @GetMapping
    @Operation(summary = "获取购物车列表")
    public ResponseEntity<ApiResponse<CartSummary>> getCartItems(
            @RequestHeader("Authorization") String token) {
        
        Long userId = jwtUtil.getUserIdFromToken(token);
        CartSummary summary = cartService.getCartSummary(userId);
        
        return ResponseEntity.ok(ApiResponse.success(summary));
    }
    
    @PutMapping("/update")
    @Operation(summary = "更新购物车商品数量")
    public ResponseEntity<ApiResponse<Void>> updateQuantity(
            @RequestHeader("Authorization") String token,
            @Valid @RequestBody UpdateCartRequest request) {
        
        Long userId = jwtUtil.getUserIdFromToken(token);
        cartService.updateQuantity(userId, request.getProductId(), request.getQuantity());
        
        return ResponseEntity.ok(ApiResponse.success("购物车已更新"));
    }
    
    @DeleteMapping("/{productId}")
    @Operation(summary = "从购物车移除商品")
    public ResponseEntity<ApiResponse<Void>> removeFromCart(
            @RequestHeader("Authorization") String token,
            @PathVariable Long productId) {
        
        Long userId = jwtUtil.getUserIdFromToken(token);
        cartService.removeFromCart(userId, productId);
        
        return ResponseEntity.ok(ApiResponse.success("商品已从购物车移除"));
    }
}
```

## 💳 支付系统

### 支付服务架构

#### 1. 支付方式枚举

```java
public enum PaymentMethod {
    ALIPAY("alipay", "支付宝"),
    WECHAT("wechat", "微信支付"),
    BANK_CARD("bank_card", "银行卡"),
    BALANCE("balance", "余额支付"),
    CREDIT("credit", "信用支付");
    
    private final String code;
    private final String name;
}

public enum PaymentStatus {
    PENDING,    // 待支付
    PROCESSING, // 处理中
    SUCCESS,    // 支付成功
    FAILED,     // 支付失败
    CANCELLED,  // 已取消
    REFUNDED    // 已退款
}
```

#### 2. 支付记录实体

```java
@Entity
@Table(name = "payments")
@Data
public class Payment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String paymentNo;
    
    @Column(nullable = false)
    private Long orderId;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;
    
    @Enumerated(EnumType.STRING)
    private PaymentMethod paymentMethod;
    
    @Enumerated(EnumType.STRING)
    private PaymentStatus status = PaymentStatus.PENDING;
    
    @Column(length = 500)
    private String failureReason;
    
    // 第三方支付平台返回的交易号
    private String thirdPartyTransactionId;
    
    private LocalDateTime createTime;
    private LocalDateTime payTime;
    private LocalDateTime expireTime;
}
```

#### 3. 支付接口实现

```java
@Service
@Slf4j
public class PaymentService {
    
    @Autowired
    private PaymentMapper paymentMapper;
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private InventoryService inventoryService;
    
    /**
     * 创建支付订单
     */
    @Transactional
    public PaymentResult createPayment(CreatePaymentRequest request) {
        // 1. 验证订单状态
        Orders order = orderService.getById(request.getOrderId());
        if (!OrderStatus.PENDING.equals(order.getStatus())) {
            throw new BusinessException("订单状态不允许支付");
        }
        
        // 2. 创建支付记录
        Payment payment = Payment.builder()
            .paymentNo(generatePaymentNo())
            .orderId(request.getOrderId())
            .userId(request.getUserId())
            .amount(order.getTotalAmount())
            .paymentMethod(request.getPaymentMethod())
            .expireTime(LocalDateTime.now().plusMinutes(30))
            .build();
        
        paymentMapper.insert(payment);
        
        // 3. 调用第三方支付接口
        ThirdPartyPaymentResult thirdPartyResult = callThirdPartyPayment(payment);
        
        return PaymentResult.builder()
            .paymentNo(payment.getPaymentNo())
            .qrCode(thirdPartyResult.getQrCode())
            .redirectUrl(thirdPartyResult.getRedirectUrl())
            .build();
    }
    
    /**
     * 支付回调处理
     */
    @Transactional
    public void handlePaymentCallback(PaymentCallbackRequest request) {
        Payment payment = paymentMapper.selectByPaymentNo(request.getPaymentNo());
        if (payment == null) {
            log.warn("支付回调：找不到支付记录，支付单号：{}", request.getPaymentNo());
            return;
        }
        
        if (PaymentStatus.SUCCESS.equals(payment.getStatus())) {
            log.info("支付回调：支付已成功，忽略重复回调，支付单号：{}", request.getPaymentNo());
            return;
        }
        
        // 更新支付状态
        payment.setStatus(PaymentStatus.SUCCESS);
        payment.setPayTime(LocalDateTime.now());
        payment.setThirdPartyTransactionId(request.getTransactionId());
        paymentMapper.updateById(payment);
        
        // 更新订单状态
        orderService.updateStatus(payment.getOrderId(), OrderStatus.PAID);
        
        // 确认扣减库存
        Orders order = orderService.getById(payment.getOrderId());
        inventoryService.confirmStock(order.getProductId(), order.getQuantity());
        
        // 发送支付成功消息
        sendPaymentSuccessMessage(payment);
    }
    
    private void sendPaymentSuccessMessage(Payment payment) {
        // 发送MQ消息或异步通知
    }
}
```

## 🎊 促销活动模块

### 秒杀活动设计

#### 1. 秒杀活动实体

```java
@Entity
@Table(name = "seckill_activities")
@Data
public class SeckillActivity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private Long productId;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal seckillPrice;
    
    @Column(nullable = false)
    private Integer seckillStock;
    
    @Column(nullable = false)
    private Integer soldCount = 0;
    
    @Column(nullable = false)
    private LocalDateTime startTime;
    
    @Column(nullable = false)
    private LocalDateTime endTime;
    
    @Enumerated(EnumType.STRING)
    private ActivityStatus status = ActivityStatus.PENDING;
    
    // 限购数量
    private Integer limitPerUser = 1;
    
    private LocalDateTime createTime;
}

public enum ActivityStatus {
    PENDING,    // 待开始
    ACTIVE,     // 进行中
    ENDED,      // 已结束
    CANCELLED   // 已取消
}
```

#### 2. 秒杀服务实现

```java
@Service
@Slf4j
public class SeckillService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private SeckillActivityMapper seckillMapper;
    
    private static final String SECKILL_STOCK_KEY = "seckill:stock:";
    private static final String SECKILL_USER_KEY = "seckill:user:";
    
    /**
     * 参与秒杀
     */
    public SeckillResult participateSeckill(Long activityId, Long userId) {
        // 1. 检查活动状态
        SeckillActivity activity = seckillMapper.selectById(activityId);
        if (!isActivityValid(activity)) {
            return SeckillResult.fail("活动不存在或已结束");
        }
        
        // 2. 检查用户是否已参与
        String userKey = SECKILL_USER_KEY + activityId + ":" + userId;
        if (redisTemplate.hasKey(userKey)) {
            return SeckillResult.fail("您已参与过该活动");
        }
        
        // 3. 尝试扣减库存
        String stockKey = SECKILL_STOCK_KEY + activityId;
        String luaScript = """
            local stockKey = KEYS[1]
            local userKey = KEYS[2]
            local userId = ARGV[1]
            
            local currentStock = tonumber(redis.call('GET', stockKey) or 0)
            if currentStock > 0 then
                redis.call('DECR', stockKey)
                redis.call('SETEX', userKey, 86400, userId)
                return 1
            else
                return 0
            end
            """;
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(luaScript);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Arrays.asList(stockKey, userKey), 
            userId.toString());
        
        if (result != null && result == 1) {
            // 异步创建订单
            createSeckillOrderAsync(activity, userId);
            return SeckillResult.success("秒杀成功，请及时支付");
        } else {
            return SeckillResult.fail("商品已售罄");
        }
    }
    
    @Async
    private void createSeckillOrderAsync(SeckillActivity activity, Long userId) {
        try {
            CreateOrderRequest orderRequest = CreateOrderRequest.builder()
                .userId(userId)
                .productId(activity.getProductId())
                .quantity(1)
                .totalAmount(activity.getSeckillPrice())
                .orderType(OrderType.SECKILL)
                .seckillActivityId(activity.getId())
                .build();
            
            orderService.createOrder(orderRequest);
            log.info("秒杀订单创建成功，活动ID: {}, 用户ID: {}", activity.getId(), userId);
        } catch (Exception e) {
            log.error("秒杀订单创建失败", e);
            // 回滚库存
            rollbackSeckillStock(activity.getId(), userId);
        }
    }
}
```

### 优惠券系统

#### 1. 优惠券实体设计

```java
@Entity
@Table(name = "coupons")
@Data
public class Coupon {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String code;
    
    @Enumerated(EnumType.STRING)
    private CouponType type;
    
    // 折扣值：满减金额或折扣比例
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal discountValue;
    
    // 使用门槛
    @Column(precision = 10, scale = 2)
    private BigDecimal minAmount;
    
    // 发行总量
    @Column(nullable = false)
    private Integer totalCount;
    
    // 已领取数量
    @Column(nullable = false)
    private Integer receivedCount = 0;
    
    // 已使用数量
    @Column(nullable = false)
    private Integer usedCount = 0;
    
    @Column(nullable = false)
    private LocalDateTime startTime;
    
    @Column(nullable = false)
    private LocalDateTime endTime;
    
    @Enumerated(EnumType.STRING)
    private CouponStatus status = CouponStatus.ACTIVE;
}

public enum CouponType {
    FULL_REDUCTION,  // 满减
    DISCOUNT,        // 折扣
    FIXED_AMOUNT     // 固定金额
}

@Entity
@Table(name = "user_coupons")
@Data
public class UserCoupon {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false)
    private Long couponId;
    
    @Enumerated(EnumType.STRING)
    private UserCouponStatus status = UserCouponStatus.UNUSED;
    
    private Long orderId; // 使用的订单ID
    
    private LocalDateTime receiveTime;
    private LocalDateTime useTime;
    private LocalDateTime expireTime;
}
```

## 📬 消息通知模块

### 消息服务设计

#### 1. 消息实体

```java
@Entity
@Table(name = "messages")
@Data
public class Message {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long userId;
    
    @Column(nullable = false)
    private String title;
    
    @Column(columnDefinition = "TEXT")
    private String content;
    
    @Enumerated(EnumType.STRING)
    private MessageType type;
    
    @Column(nullable = false)
    private Boolean isRead = false;
    
    private LocalDateTime createTime;
    private LocalDateTime readTime;
}

public enum MessageType {
    SYSTEM,      // 系统消息
    ORDER,       // 订单消息
    PROMOTION,   // 促销消息
    PAYMENT      // 支付消息
}
```

#### 2. 邮件通知服务

```java
@Service
@Slf4j
public class EmailNotificationService {
    
    @Autowired
    private JavaMailSender mailSender;
    
    @Value("${spring.mail.username}")
    private String fromEmail;
    
    @Async
    public void sendOrderConfirmationEmail(String toEmail, Orders order) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
            
            helper.setFrom(fromEmail);
            helper.setTo(toEmail);
            helper.setSubject("订单确认通知 - " + order.getOrderNo());
            
            String content = buildOrderConfirmationContent(order);
            helper.setText(content, true);
            
            mailSender.send(message);
            log.info("订单确认邮件发送成功，收件人: {}, 订单号: {}", toEmail, order.getOrderNo());
        } catch (Exception e) {
            log.error("订单确认邮件发送失败", e);
        }
    }
    
    private String buildOrderConfirmationContent(Orders order) {
        return String.format("""
            <html>
            <body>
                <h2>订单确认</h2>
                <p>尊敬的用户，您的订单已确认：</p>
                <ul>
                    <li>订单号：%s</li>
                    <li>订单金额：￥%.2f</li>
                    <li>下单时间：%s</li>
                </ul>
                <p>我们将尽快为您处理订单，感谢您的购买！</p>
            </body>
            </html>
            """, 
            order.getOrderNo(), 
            order.getTotalAmount(), 
            order.getCreateTime());
    }
}
```

## 🔄 分布式事务

### Seata 集成

#### 1. 依赖配置

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
</dependency>
```

#### 2. 分布式事务实现

```java
@Service
@Slf4j
public class OrderTransactionService {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private UserService userService;
    
    /**
     * 创建订单的分布式事务
     */
    @GlobalTransactional(name = "create-order-transaction", rollbackFor = Exception.class)
    public OrderResult createOrderWithTransaction(CreateOrderRequest request) {
        try {
            // 1. 扣减库存
            boolean stockReserved = inventoryService.reserveStock(
                request.getProductId(), request.getQuantity());
            if (!stockReserved) {
                throw new BusinessException("库存不足");
            }
            
            // 2. 扣减用户余额（如果使用余额支付）
            if (PaymentMethod.BALANCE.equals(request.getPaymentMethod())) {
                userService.deductBalance(request.getUserId(), request.getTotalAmount());
            }
            
            // 3. 创建订单
            Orders order = orderService.createOrder(request);
            
            // 4. 创建支付记录
            if (!PaymentMethod.BALANCE.equals(request.getPaymentMethod())) {
                paymentService.createPayment(CreatePaymentRequest.builder()
                    .orderId(order.getId())
                    .userId(request.getUserId())
                    .paymentMethod(request.getPaymentMethod())
                    .build());
            }
            
            log.info("订单创建分布式事务成功，订单ID: {}", order.getId());
            return OrderResult.success(order);
            
        } catch (Exception e) {
            log.error("订单创建分布式事务失败", e);
            throw e; // 抛出异常触发全局回滚
        }
    }
}
```

## 📊 数据统计与分析

### 业务指标统计

#### 1. 销售统计服务

```java
@Service
@Slf4j
public class SalesStatisticsService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 获取销售概览
     */
    @Cacheable(value = "sales_overview", key = "#date")
    public SalesOverview getSalesOverview(LocalDate date) {
        LocalDateTime startTime = date.atStartOfDay();
        LocalDateTime endTime = date.atTime(23, 59, 59);
        
        // 订单统计
        OrderStatistics orderStats = orderMapper.getOrderStatistics(startTime, endTime);
        
        // 商品销售排行
        List<ProductSalesRank> productRanks = orderMapper.getProductSalesRank(startTime, endTime, 10);
        
        // 用户消费排行
        List<UserConsumptionRank> userRanks = orderMapper.getUserConsumptionRank(startTime, endTime, 10);
        
        return SalesOverview.builder()
            .date(date)
            .orderCount(orderStats.getOrderCount())
            .totalAmount(orderStats.getTotalAmount())
            .avgOrderAmount(orderStats.getAvgOrderAmount())
            .productRanks(productRanks)
            .userRanks(userRanks)
            .build();
    }
    
    /**
     * 实时销售数据
     */
    public RealtimeSalesData getRealtimeSalesData() {
        String todayKey = "sales:today:" + LocalDate.now();
        
        Map<Object, Object> todayData = redisTemplate.opsForHash().entries(todayKey);
        
        return RealtimeSalesData.builder()
            .todayOrderCount(getLongValue(todayData, "orderCount"))
            .todayAmount(getBigDecimalValue(todayData, "amount"))
            .onlineUserCount(getOnlineUserCount())
            .build();
    }
    
    /**
     * 更新实时销售数据
     */
    @EventListener
    public void handleOrderPaidEvent(OrderPaidEvent event) {
        String todayKey = "sales:today:" + LocalDate.now();
        
        redisTemplate.opsForHash().increment(todayKey, "orderCount", 1);
        redisTemplate.opsForHash().increment(todayKey, "amount", 
            event.getOrder().getTotalAmount().doubleValue());
        
        // 设置过期时间为明天凌晨
        redisTemplate.expireAt(todayKey, 
            LocalDate.now().plusDays(1).atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());
    }
}
```

---

## 🚀 实施计划

### 第一阶段：核心业务扩展 (2周)

1. **商品管理模块**: 商品CRUD、分类管理、库存管理
2. **购物车功能**: 添加/删除商品、数量调整、收藏功能
3. **基础支付**: 支付宝、微信支付集成

### 第二阶段：高级功能 (2周)

1. **库存优化**: 预扣库存、分布式锁、库存回滚
2. **促销系统**: 优惠券、秒杀活动
3. **消息通知**: 邮件、站内消息

### 第三阶段：分布式事务与统计 (1周)

1. **Seata集成**: 分布式事务处理
2. **数据统计**: 销售统计、实时数据
3. **性能优化**: 缓存策略、异步处理

通过以上业务功能扩展，CloudDemo项目将成为一个功能完整、技术全面的电商微服务系统，大大提升项目的面试价值和技术含量。
