# CloudDemo 微服务各组件深度使用方案

## 🎯 深度使用目标

在现有CloudDemo项目基础上，深入挖掘各个技术组件的高级特性和最佳实践，提升技术深度和面试竞争力：

- **Nacos高级特性**: 命名空间、配置加密、权限控制
- **Dubbo深度应用**: 自定义负载均衡、SPI扩展、协议优化
- **Sentinel进阶功能**: 热点参数限流、系统自适应保护、集群流控
- **Spring Cloud Gateway增强**: 自定义过滤器、限流熔断、安全认证
- **Redis高级应用**: 分布式锁、消息队列、数据结构优化
- **MyBatis Plus扩展**: 自定义字段填充、多数据源、性能优化

## 🏗️ Nacos 高级特性应用

### 命名空间多环境隔离

#### 1. 命名空间配置

```java
@Configuration
public class NacosNamespaceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.cloud.nacos.discovery")
    public NacosDiscoveryProperties nacosDiscoveryProperties() {
        NacosDiscoveryProperties properties = new NacosDiscoveryProperties();
        
        // 根据环境动态设置命名空间
        String activeProfile = environment.getActiveProfiles()[0];
        switch (activeProfile) {
            case "dev":
                properties.setNamespace("dev-namespace-id");
                break;
            case "test":
                properties.setNamespace("test-namespace-id");
                break;
            case "prod":
                properties.setNamespace("prod-namespace-id");
                break;
            default:
                properties.setNamespace("public");
        }
        
        return properties;
    }
}
```

#### 2. 配置加密解密

```java
@Component
@Slf4j
public class ConfigDecryptProcessor implements ApplicationRunner {
    
    @Autowired
    private NacosConfigManager nacosConfigManager;
    
    @Autowired
    private AESUtil aesUtil;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 获取加密配置并解密
        String encryptedConfig = nacosConfigManager.getConfigService()
            .getConfig("encrypted-config.properties", "DEFAULT_GROUP", 5000);
        
        if (StringUtils.hasText(encryptedConfig)) {
            Properties decryptedProps = decryptProperties(encryptedConfig);
            // 将解密后的配置注入到环境中
            MutablePropertySources propertySources = environment.getPropertySources();
            propertySources.addFirst(new PropertiesPropertySource("decrypted-config", decryptedProps));
        }
    }
    
    private Properties decryptProperties(String encryptedConfig) {
        Properties properties = new Properties();
        String[] lines = encryptedConfig.split("\n");
        
        for (String line : lines) {
            if (line.contains("=") && line.startsWith("ENC(")) {
                String[] parts = line.split("=", 2);
                String key = parts[0];
                String encryptedValue = parts[1];
                
                // 解密值
                String decryptedValue = aesUtil.decrypt(
                    encryptedValue.substring(4, encryptedValue.length() - 1));
                
                properties.setProperty(key, decryptedValue);
                log.info("配置解密成功: {}", key);
            }
        }
        
        return properties;
    }
}
```

### 配置变更监听与灰度发布

#### 1. 配置变更监听器

```java
@Component
@Slf4j
public class DynamicConfigListener {
    
    @Autowired
    private ConfigurableApplicationContext applicationContext;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @NacosConfigListener(dataId = "dynamic-config.properties", groupId = "DEFAULT_GROUP")
    public void onConfigChange(String configInfo) {
        log.info("检测到配置变更: {}", configInfo);
        
        try {
            // 解析新配置
            Properties newProperties = parseProperties(configInfo);
            
            // 验证配置合法性
            validateConfiguration(newProperties);
            
            // 灰度发布配置
            performGrayReleaseConfig(newProperties);
            
            // 刷新应用上下文
            ContextRefresher contextRefresher = new ContextRefresher(applicationContext);
            contextRefresher.refresh();
            
            log.info("配置热更新成功");
            
        } catch (Exception e) {
            log.error("配置热更新失败", e);
            // 发送告警通知
            sendConfigUpdateFailAlert(e.getMessage());
        }
    }
    
    private void performGrayReleaseConfig(Properties newProperties) {
        // 灰度节点标识
        String grayFlag = System.getProperty("gray.release", "false");
        
        if ("true".equals(grayFlag)) {
            // 灰度节点先应用新配置
            applyNewConfiguration(newProperties);
            
            // 监控灰度节点健康状况
            monitorGrayNodeHealth();
            
            log.info("灰度配置发布完成");
        } else {
            // 等待灰度验证通过后再应用
            waitForGrayValidation();
            applyNewConfiguration(newProperties);
        }
    }
}
```

## 🚀 Dubbo 深度应用

### 自定义负载均衡策略

#### 1. 权重自适应负载均衡

```java
@SPI("adaptive_weight")
public class AdaptiveWeightLoadBalance extends AbstractLoadBalance {
    
    private final ConcurrentMap<String, WeightedRoundRobin> methodWeightMap = new ConcurrentHashMap<>();
    
    @Override
    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
        String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
        int length = invokers.size();
        
        boolean sameWeight = true;
        int[] weights = new int[length];
        int firstWeight = getWeight(invokers.get(0), invocation);
        int totalWeight = firstWeight;
        
        // 计算权重并检测是否相同
        for (int i = 1; i < length; i++) {
            int weight = getWeight(invokers.get(i), invocation);
            weights[i] = weight;
            totalWeight += weight;
            if (sameWeight && weight != firstWeight) {
                sameWeight = false;
            }
        }
        
        WeightedRoundRobin wrr = methodWeightMap.computeIfAbsent(key, k -> new WeightedRoundRobin());
        
        if (totalWeight > 0 && !sameWeight) {
            return selectByWeight(invokers, weights, totalWeight, wrr);
        }
        
        // 权重相同时使用轮询
        return invokers.get((int) (wrr.incrementAndGet() % length));
    }
    
    private <T> Invoker<T> selectByWeight(List<Invoker<T>> invokers, int[] weights, 
                                         int totalWeight, WeightedRoundRobin wrr) {
        int offset = (int) (wrr.incrementAndGet() % totalWeight);
        for (int i = 0; i < weights.length; i++) {
            offset -= weights[i];
            if (offset < 0) {
                return invokers.get(i);
            }
        }
        return invokers.get(0);
    }
    
    protected int getWeight(Invoker<?> invoker, Invocation invocation) {
        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), "weight", 100);
        
        // 根据响应时间动态调整权重
        long avgResponseTime = getAverageResponseTime(invoker);
        if (avgResponseTime > 0) {
            // 响应时间越长，权重越低
            weight = (int) (weight * (1000.0 / (avgResponseTime + 1000)));
        }
        
        return Math.max(weight, 1);
    }
    
    private long getAverageResponseTime(Invoker<?> invoker) {
        // 从监控数据中获取平均响应时间
        RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), 
            RpcContext.getContext().getMethodName());
        return rpcStatus.getAverageElapsed();
    }
}
```

#### 2. 自定义过滤器

```java
@Activate(group = {CONSUMER, PROVIDER})
public class PerformanceMonitorFilter implements Filter {
    
    private static final Logger logger = LoggerFactory.getLogger(PerformanceMonitorFilter.class);
    
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        long startTime = System.currentTimeMillis();
        String methodName = invocation.getMethodName();
        String serviceName = invoker.getUrl().getServiceInterface();
        
        try {
            Result result = invoker.invoke(invocation);
            
            long elapsed = System.currentTimeMillis() - startTime;
            recordPerformanceMetrics(serviceName, methodName, elapsed, true);
            
            // 慢调用告警
            if (elapsed > getSlowCallThreshold(serviceName, methodName)) {
                logger.warn("检测到慢调用: {}#{}, 耗时: {}ms", serviceName, methodName, elapsed);
                sendSlowCallAlert(serviceName, methodName, elapsed);
            }
            
            return result;
            
        } catch (Exception e) {
            long elapsed = System.currentTimeMillis() - startTime;
            recordPerformanceMetrics(serviceName, methodName, elapsed, false);
            
            logger.error("RPC调用异常: {}#{}", serviceName, methodName, e);
            throw e;
        }
    }
    
    private void recordPerformanceMetrics(String serviceName, String methodName, 
                                        long elapsed, boolean success) {
        // 记录到监控系统
        MetricRegistry.timer(serviceName + "." + methodName + ".timer")
            .update(elapsed, TimeUnit.MILLISECONDS);
        
        if (success) {
            MetricRegistry.counter(serviceName + "." + methodName + ".success").inc();
        } else {
            MetricRegistry.counter(serviceName + "." + methodName + ".error").inc();
        }
    }
}
```

### SPI 扩展机制

#### 1. 自定义注册中心扩展

```java
@SPI("consul")
public class ConsulRegistry extends AbstractRegistry {
    
    private final ConsulClient consulClient;
    private final ScheduledExecutorService heartbeatExecutor;
    
    public ConsulRegistry(URL url) {
        super(url);
        this.consulClient = new ConsulClient(url.getHost(), url.getPort());
        this.heartbeatExecutor = Executors.newScheduledThreadPool(1);
        startHeartbeat();
    }
    
    @Override
    public void doRegister(URL url) {
        try {
            NewService newService = new NewService();
            newService.setId(buildServiceId(url));
            newService.setName(url.getServiceInterface());
            newService.setAddress(url.getHost());
            newService.setPort(url.getPort());
            
            // 健康检查配置
            NewService.Check check = new NewService.Check();
            check.setHttp("http://" + url.getHost() + ":" + url.getPort() + "/health");
            check.setInterval("10s");
            check.setTimeout("3s");
            newService.setCheck(check);
            
            consulClient.agentServiceRegister(newService);
            logger.info("服务注册成功: {}", url);
            
        } catch (Exception e) {
            throw new RpcException("注册服务失败: " + url, e);
        }
    }
    
    @Override
    public void doUnregister(URL url) {
        try {
            consulClient.agentServiceDeregister(buildServiceId(url));
            logger.info("服务注销成功: {}", url);
        } catch (Exception e) {
            logger.warn("注销服务失败: " + url, e);
        }
    }
    
    @Override
    public void doSubscribe(URL url, NotifyListener listener) {
        // 实现服务发现逻辑
        List<HealthService> healthServices = consulClient.getHealthServices(
            url.getServiceInterface(), true, null).getValue();
        
        List<URL> urls = healthServices.stream()
            .map(service -> buildProviderUrl(service))
            .collect(Collectors.toList());
        
        listener.notify(urls);
    }
}
```

## ⚡ Sentinel 进阶功能

### 热点参数限流

#### 1. 热点参数配置

```java
@RestController
@RequestMapping("/products")
public class ProductController {
    
    @GetMapping("/{productId}")
    @SentinelResource(value = "getProduct", blockHandler = "handleProductBlock")
    public ResponseEntity<Product> getProduct(
            @PathVariable("productId") Long productId,
            @RequestParam(defaultValue = "1") Integer version) {
        
        // 业务逻辑
        Product product = productService.getById(productId);
        return ResponseEntity.ok(product);
    }
    
    public ResponseEntity<Product> handleProductBlock(Long productId, Integer version, 
                                                     BlockException ex) {
        // 热点商品降级处理
        Product cachedProduct = productService.getFromCache(productId);
        if (cachedProduct != null) {
            return ResponseEntity.ok(cachedProduct);
        }
        
        return ResponseEntity.status(429)
            .body(Product.builder().id(productId).name("商品访问过于频繁，请稍后重试").build());
    }
}

@Configuration
public class SentinelHotParamConfig {
    
    @PostConstruct
    public void initHotParamRules() {
        List<ParamFlowRule> rules = new ArrayList<>();
        
        // 配置商品ID热点参数限流
        ParamFlowRule rule = new ParamFlowRule();
        rule.setResource("getProduct");
        rule.setParamIdx(0); // 第一个参数（productId）
        rule.setCount(10);   // QPS限制
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        
        // 热点商品特殊配置
        Map<Object, Integer> paramMap = new HashMap<>();
        paramMap.put(1001L, 50);  // 热门商品ID=1001，QPS=50
        paramMap.put(1002L, 30);  // 热门商品ID=1002，QPS=30
        rule.setParamFlowItemList(paramMap.entrySet().stream()
            .map(entry -> new ParamFlowItem()
                .setObject(entry.getKey().toString())
                .setClassType(Long.class.getName())
                .setCount(entry.getValue()))
            .collect(Collectors.toList()));
        
        rules.add(rule);
        ParamFlowRuleManager.loadRules(rules);
    }
}
```

### 系统自适应保护

#### 1. 自适应限流配置

```java
@Configuration
public class SentinelSystemConfig {
    
    @PostConstruct
    public void initSystemRules() {
        List<SystemRule> rules = new ArrayList<>();
        
        // CPU使用率保护
        SystemRule cpuRule = new SystemRule();
        cpuRule.setHighestCpuUsage(0.8); // CPU使用率超过80%时限流
        rules.add(cpuRule);
        
        // 系统负载保护
        SystemRule loadRule = new SystemRule();
        loadRule.setHighestSystemLoad(10.0); // 系统负载超过10时限流
        rules.add(loadRule);
        
        // 平均响应时间保护
        SystemRule rtRule = new SystemRule();
        rtRule.setAvgRt(1000); // 平均响应时间超过1秒时限流
        rules.add(rtRule);
        
        // 并发线程数保护
        SystemRule threadRule = new SystemRule();
        threadRule.setMaxThread(100); // 并发线程数超过100时限流
        rules.add(threadRule);
        
        SystemRuleManager.loadRules(rules);
    }
}
```

#### 2. 自定义系统指标采集

```java
@Component
@Slf4j
public class CustomSystemMetricCollector {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Scheduled(fixedRate = 1000) // 每秒采集一次
    public void collectMetrics() {
        // 采集JVM指标
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        double memoryUsage = (double) usedMemory / totalMemory;
        meterRegistry.gauge("jvm.memory.usage", memoryUsage);
        
        // 采集数据库连接池指标
        HikariDataSource dataSource = getDataSource();
        if (dataSource != null) {
            HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();
            meterRegistry.gauge("hikari.connections.active", poolBean.getActiveConnections());
            meterRegistry.gauge("hikari.connections.idle", poolBean.getIdleConnections());
            meterRegistry.gauge("hikari.connections.total", poolBean.getTotalConnections());
        }
        
        // 采集Redis连接指标
        LettuceConnectionFactory redisFactory = getRedisConnectionFactory();
        if (redisFactory != null) {
            // 获取Redis连接状态
            meterRegistry.gauge("redis.connections.active", getActiveRedisConnections());
        }
    }
    
    @EventListener
    public void handleSystemOverload(SystemOverloadEvent event) {
        log.warn("系统过载检测: {}", event.getMetricType());
        
        switch (event.getMetricType()) {
            case CPU:
                handleCpuOverload(event.getValue());
                break;
            case MEMORY:
                handleMemoryOverload(event.getValue());
                break;
            case LOAD:
                handleLoadOverload(event.getValue());
                break;
        }
    }
}
```

## 🌐 Spring Cloud Gateway 增强

### 自定义全局过滤器

#### 1. 请求追踪过滤器

```java
@Component
@Slf4j
public class RequestTrackingGlobalFilter implements GlobalFilter, Ordered {
    
    private static final String TRACE_ID_HEADER = "X-Trace-Id";
    private static final String START_TIME_ATTR = "startTime";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String traceId = getOrGenerateTraceId(request);
        
        // 设置追踪上下文
        exchange.getAttributes().put(START_TIME_ATTR, System.currentTimeMillis());
        
        // 修改请求头，添加追踪ID
        ServerHttpRequest modifiedRequest = request.mutate()
            .header(TRACE_ID_HEADER, traceId)
            .build();
        
        ServerWebExchange modifiedExchange = exchange.mutate()
            .request(modifiedRequest)
            .build();
        
        return chain.filter(modifiedExchange)
            .doFinally(signalType -> {
                // 记录请求完成信息
                long startTime = (Long) exchange.getAttributes().get(START_TIME_ATTR);
                long duration = System.currentTimeMillis() - startTime;
                
                logRequestCompletion(request, traceId, duration, signalType);
            });
    }
    
    private String getOrGenerateTraceId(ServerHttpRequest request) {
        String traceId = request.getHeaders().getFirst(TRACE_ID_HEADER);
        return StringUtils.hasText(traceId) ? traceId : generateTraceId();
    }
    
    private String generateTraceId() {
        return UUID.randomUUID().toString().replace("-", "");
    }
    
    private void logRequestCompletion(ServerHttpRequest request, String traceId, 
                                    long duration, SignalType signalType) {
        log.info("请求完成 - TraceId: {}, Method: {}, URI: {}, Duration: {}ms, Signal: {}", 
            traceId, request.getMethod(), request.getURI(), duration, signalType);
        
        // 记录到监控系统
        Metrics.timer("gateway.request.duration", 
            "method", request.getMethod().name(),
            "path", request.getPath().toString())
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    @Override
    public int getOrder() {
        return -1; // 最高优先级
    }
}
```

#### 2. 智能限流过滤器

```java
@Component
public class IntelligentRateLimitGatewayFilter implements GatewayFilter, Ordered {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private UserBehaviorAnalyzer userBehaviorAnalyzer;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return determineRateLimit(exchange)
            .flatMap(rateLimit -> {
                if (rateLimit.isAllowed()) {
                    return chain.filter(exchange);
                } else {
                    return handleRateLimitExceeded(exchange, rateLimit);
                }
            });
    }
    
    private Mono<RateLimitResult> determineRateLimit(ServerWebExchange exchange) {
        return Mono.fromCallable(() -> {
            String clientId = getClientId(exchange.getRequest());
            String path = exchange.getRequest().getPath().toString();
            
            // 基于用户行为的动态限流
            UserBehavior behavior = userBehaviorAnalyzer.analyze(clientId);
            RateLimitConfig config = buildRateLimitConfig(behavior, path);
            
            return executeRateLimit(clientId, path, config);
        }).subscribeOn(Schedulers.boundedElastic());
    }
    
    private RateLimitConfig buildRateLimitConfig(UserBehavior behavior, String path) {
        RateLimitConfig config = new RateLimitConfig();
        
        // 根据用户等级调整限流策略
        switch (behavior.getUserLevel()) {
            case VIP:
                config.setRequestsPerSecond(100);
                config.setBurstCapacity(200);
                break;
            case NORMAL:
                config.setRequestsPerSecond(50);
                config.setBurstCapacity(100);
                break;
            case SUSPICIOUS:
                config.setRequestsPerSecond(10);
                config.setBurstCapacity(20);
                break;
        }
        
        // 根据路径类型调整
        if (path.startsWith("/api/public")) {
            config.setRequestsPerSecond(config.getRequestsPerSecond() * 2);
        } else if (path.startsWith("/api/admin")) {
            config.setRequestsPerSecond(config.getRequestsPerSecond() / 2);
        }
        
        return config;
    }
    
    private RateLimitResult executeRateLimit(String clientId, String path, RateLimitConfig config) {
        String key = "rate_limit:" + clientId + ":" + path;
        
        // 使用令牌桶算法
        return TokenBucketRateLimiter.builder()
            .redisTemplate(redisTemplate)
            .key(key)
            .capacity(config.getBurstCapacity())
            .refillRate(config.getRequestsPerSecond())
            .build()
            .tryAcquire();
    }
}
```

### 动态路由管理

#### 1. 路由配置管理器

```java
@Component
@Slf4j
public class DynamicRouteManager {
    
    @Autowired
    private RouteDefinitionWriter routeDefinitionWriter;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @Autowired
    private RouteDefinitionRepository routeDefinitionRepository;
    
    /**
     * 动态添加路由
     */
    public Mono<ResponseEntity<String>> addRoute(RouteDefinition routeDefinition) {
        return routeDefinitionWriter.save(Mono.just(routeDefinition))
            .then(Mono.defer(() -> {
                // 发布路由刷新事件
                eventPublisher.publishEvent(new RefreshRoutesEvent(this));
                log.info("动态路由添加成功: {}", routeDefinition.getId());
                return Mono.just(ResponseEntity.ok("路由添加成功"));
            }))
            .onErrorResume(ex -> {
                log.error("动态路由添加失败", ex);
                return Mono.just(ResponseEntity.badRequest().body("路由添加失败: " + ex.getMessage()));
            });
    }
    
    /**
     * 动态删除路由
     */
    public Mono<ResponseEntity<String>> removeRoute(String routeId) {
        return routeDefinitionWriter.delete(Mono.just(routeId))
            .then(Mono.defer(() -> {
                eventPublisher.publishEvent(new RefreshRoutesEvent(this));
                log.info("动态路由删除成功: {}", routeId);
                return Mono.just(ResponseEntity.ok("路由删除成功"));
            }))
            .onErrorResume(ex -> {
                log.error("动态路由删除失败", ex);
                return Mono.just(ResponseEntity.badRequest().body("路由删除失败: " + ex.getMessage()));
            });
    }
    
    /**
     * 基于服务健康状态的路由切换
     */
    @EventListener
    public void handleServiceHealthChange(ServiceHealthChangeEvent event) {
        if (!event.isHealthy()) {
            log.warn("检测到服务不健康，准备切换路由: {}", event.getServiceName());
            
            // 获取备用服务路由
            RouteDefinition backupRoute = getBackupRoute(event.getServiceName());
            if (backupRoute != null) {
                addRoute(backupRoute).subscribe();
            }
            
            // 禁用不健康的服务路由
            disableRoute(event.getServiceName());
        } else {
            log.info("服务恢复健康，恢复原始路由: {}", event.getServiceName());
            enableRoute(event.getServiceName());
        }
    }
}
```

## 🔴 Redis 高级应用

### 分布式锁实现

#### 1. 可重入分布式锁

```java
@Component
@Slf4j
public class RedisDistributedLock {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String LOCK_PREFIX = "distributed_lock:";
    private static final String REENTRANT_PREFIX = "reentrant:";
    private static final ThreadLocal<Map<String, Integer>> LOCK_COUNT_MAP = new ThreadLocal<>();
    
    /**
     * 尝试获取锁
     */
    public boolean tryLock(String key, long expireTime, TimeUnit timeUnit) {
        String lockKey = LOCK_PREFIX + key;
        String reentrantKey = REENTRANT_PREFIX + key;
        String threadId = getThreadId();
        
        // 检查重入
        Map<String, Integer> lockCountMap = LOCK_COUNT_MAP.get();
        if (lockCountMap == null) {
            lockCountMap = new HashMap<>();
            LOCK_COUNT_MAP.set(lockCountMap);
        }
        
        Integer count = lockCountMap.get(key);
        if (count != null && count > 0) {
            // 重入锁
            lockCountMap.put(key, count + 1);
            redisTemplate.opsForValue().increment(reentrantKey);
            return true;
        }
        
        // 尝试获取新锁
        Boolean success = redisTemplate.opsForValue().setIfAbsent(
            lockKey, threadId, expireTime, timeUnit);
        
        if (success != null && success) {
            lockCountMap.put(key, 1);
            redisTemplate.opsForValue().set(reentrantKey, "1", expireTime, timeUnit);
            
            // 启动锁续期任务
            startLockRenewal(lockKey, threadId, expireTime, timeUnit);
            return true;
        }
        
        return false;
    }
    
    /**
     * 释放锁
     */
    public boolean unlock(String key) {
        String lockKey = LOCK_PREFIX + key;
        String reentrantKey = REENTRANT_PREFIX + key;
        String threadId = getThreadId();
        
        Map<String, Integer> lockCountMap = LOCK_COUNT_MAP.get();
        if (lockCountMap == null) {
            return false;
        }
        
        Integer count = lockCountMap.get(key);
        if (count == null || count <= 0) {
            return false;
        }
        
        if (count > 1) {
            // 重入锁计数递减
            lockCountMap.put(key, count - 1);
            redisTemplate.opsForValue().decrement(reentrantKey);
            return true;
        }
        
        // 释放锁
        String luaScript = """
            if redis.call('GET', KEYS[1]) == ARGV[1] then
                redis.call('DEL', KEYS[1])
                redis.call('DEL', KEYS[2])
                return 1
            else
                return 0
            end
            """;
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(luaScript);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Arrays.asList(lockKey, reentrantKey), threadId);
        
        if (result != null && result == 1) {
            lockCountMap.remove(key);
            stopLockRenewal(lockKey);
            return true;
        }
        
        return false;
    }
    
    /**
     * 锁续期机制
     */
    private void startLockRenewal(String lockKey, String threadId, long expireTime, TimeUnit timeUnit) {
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        long renewalInterval = timeUnit.toMillis(expireTime) / 3; // 每1/3过期时间续期一次
        
        ScheduledFuture<?> renewalTask = scheduler.scheduleAtFixedRate(() -> {
            try {
                String luaScript = """
                    if redis.call('GET', KEYS[1]) == ARGV[1] then
                        return redis.call('EXPIRE', KEYS[1], ARGV[2])
                    else
                        return 0
                    end
                    """;
                
                DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
                redisScript.setScriptText(luaScript);
                redisScript.setResultType(Long.class);
                
                Long result = redisTemplate.execute(redisScript, 
                    Collections.singletonList(lockKey), 
                    threadId, String.valueOf(timeUnit.toSeconds(expireTime)));
                
                if (result == null || result == 0) {
                    log.warn("锁续期失败，停止续期任务: {}", lockKey);
                    throw new RuntimeException("锁已过期或被其他线程持有");
                }
                
                log.debug("锁续期成功: {}", lockKey);
                
            } catch (Exception e) {
                log.error("锁续期异常: " + lockKey, e);
                throw new RuntimeException(e);
            }
        }, renewalInterval, renewalInterval, TimeUnit.MILLISECONDS);
        
        // 保存续期任务以便后续取消
        RENEWAL_TASKS.put(lockKey, renewalTask);
    }
    
    private static final Map<String, ScheduledFuture<?>> RENEWAL_TASKS = new ConcurrentHashMap<>();
    
    private void stopLockRenewal(String lockKey) {
        ScheduledFuture<?> renewalTask = RENEWAL_TASKS.remove(lockKey);
        if (renewalTask != null) {
            renewalTask.cancel(true);
            log.debug("停止锁续期任务: {}", lockKey);
        }
    }
    
    private String getThreadId() {
        return Thread.currentThread().getId() + "-" + System.nanoTime();
    }
}
```

### Redis 消息队列

#### 1. 可靠消息队列实现

```java
@Component
@Slf4j
public class RedisReliableMessageQueue {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String PENDING_QUEUE = "message:pending:";
    private static final String PROCESSING_QUEUE = "message:processing:";
    private static final String DEAD_LETTER_QUEUE = "message:dlq:";
    
    /**
     * 发送消息
     */
    public void sendMessage(String topic, Object message) {
        ReliableMessage reliableMessage = ReliableMessage.builder()
            .id(UUID.randomUUID().toString())
            .topic(topic)
            .payload(message)
            .createTime(System.currentTimeMillis())
            .retryCount(0)
            .maxRetries(3)
            .build();
        
        String queueKey = PENDING_QUEUE + topic;
        redisTemplate.opsForList().leftPush(queueKey, reliableMessage);
        
        log.info("消息发送成功: topic={}, messageId={}", topic, reliableMessage.getId());
    }
    
    /**
     * 消费消息
     */
    @Async
    public void consumeMessages(String topic, MessageHandler handler) {
        String pendingKey = PENDING_QUEUE + topic;
        String processingKey = PROCESSING_QUEUE + topic;
        
        while (!Thread.currentThread().isInterrupted()) {
            try {
                // 从待处理队列移动到处理队列
                Object messageObj = redisTemplate.opsForList()
                    .rightPopAndLeftPush(pendingKey, processingKey);
                
                if (messageObj == null) {
                    Thread.sleep(100); // 队列为空时等待
                    continue;
                }
                
                ReliableMessage message = (ReliableMessage) messageObj;
                
                try {
                    // 处理消息
                    handler.handle(message);
                    
                    // 处理成功，从处理队列中移除
                    redisTemplate.opsForList().remove(processingKey, 1, message);
                    
                    log.info("消息处理成功: messageId={}", message.getId());
                    
                } catch (Exception e) {
                    log.error("消息处理失败: messageId=" + message.getId(), e);
                    handleMessageFailure(topic, message, e);
                }
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("消息消费异常", e);
            }
        }
    }
    
    /**
     * 处理消息失败
     */
    private void handleMessageFailure(String topic, ReliableMessage message, Exception e) {
        String processingKey = PROCESSING_QUEUE + topic;
        String pendingKey = PENDING_QUEUE + topic;
        String dlqKey = DEAD_LETTER_QUEUE + topic;
        
        message.setRetryCount(message.getRetryCount() + 1);
        message.setLastError(e.getMessage());
        
        // 从处理队列中移除
        redisTemplate.opsForList().remove(processingKey, 1, message);
        
        if (message.getRetryCount() < message.getMaxRetries()) {
            // 重新放入待处理队列
            redisTemplate.opsForList().leftPush(pendingKey, message);
            log.info("消息重试: messageId={}, retryCount={}", 
                message.getId(), message.getRetryCount());
        } else {
            // 超过最大重试次数，放入死信队列
            redisTemplate.opsForList().leftPush(dlqKey, message);
            log.warn("消息处理失败，移入死信队列: messageId={}", message.getId());
        }
    }
    
    /**
     * 死信队列监控
     */
    @Scheduled(fixedRate = 60000) // 每分钟检查一次
    public void monitorDeadLetterQueue() {
        Set<String> topics = getTopics();
        
        for (String topic : topics) {
            String dlqKey = DEAD_LETTER_QUEUE + topic;
            Long size = redisTemplate.opsForList().size(dlqKey);
            
            if (size != null && size > 0) {
                log.warn("死信队列发现消息: topic={}, count={}", topic, size);
                
                // 发送告警
                sendDeadLetterAlert(topic, size);
            }
        }
    }
}
```

## 📊 MyBatis Plus 扩展

### 自定义字段填充

#### 1. 元数据对象填充器

```java
@Component
@Slf4j
public class CustomMetaObjectHandler implements MetaObjectHandler {
    
    @Override
    public void insertFill(MetaObject metaObject) {
        log.debug("开始插入填充...");
        
        // 自动填充创建时间
        this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        
        // 自动填充创建人
        Long currentUserId = getCurrentUserId();
        if (currentUserId != null) {
            this.strictInsertFill(metaObject, "createBy", Long.class, currentUserId);
            this.strictInsertFill(metaObject, "updateBy", Long.class, currentUserId);
        }
        
        // 自动填充租户ID
        Long tenantId = getCurrentTenantId();
        if (tenantId != null) {
            this.strictInsertFill(metaObject, "tenantId", Long.class, tenantId);
        }
        
        // 自动填充版本号
        this.strictInsertFill(metaObject, "version", Integer.class, 1);
        
        // 自动填充逻辑删除标识
        this.strictInsertFill(metaObject, "deleted", Integer.class, 0);
    }
    
    @Override
    public void updateFill(MetaObject metaObject) {
        log.debug("开始更新填充...");
        
        // 自动填充更新时间
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        
        // 自动填充更新人
        Long currentUserId = getCurrentUserId();
        if (currentUserId != null) {
            this.strictUpdateFill(metaObject, "updateBy", Long.class, currentUserId);
        }
    }
    
    private Long getCurrentUserId() {
        try {
            // 从Security上下文或ThreadLocal获取当前用户ID
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated()) {
                Object principal = authentication.getPrincipal();
                if (principal instanceof UserPrincipal) {
                    return ((UserPrincipal) principal).getId();
                }
            }
        } catch (Exception e) {
            log.warn("获取当前用户ID失败", e);
        }
        return null;
    }
    
    private Long getCurrentTenantId() {
        // 从请求头或上下文获取租户ID
        try {
            RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
            if (requestAttributes instanceof ServletRequestAttributes) {
                HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
                String tenantId = request.getHeader("X-Tenant-Id");
                return StringUtils.hasText(tenantId) ? Long.parseLong(tenantId) : null;
            }
        } catch (Exception e) {
            log.warn("获取当前租户ID失败", e);
        }
        return null;
    }
}
```

### 多数据源配置

#### 1. 动态数据源配置

```java
@Configuration
public class DynamicDataSourceConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource() {
        return DruidDataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DruidDataSourceBuilder.create().build();
    }
    
    @Bean
    @Primary
    public DataSource dynamicDataSource() {
        DynamicRoutingDataSource dynamicDataSource = new DynamicRoutingDataSource();
        
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put(DataSourceType.MASTER, masterDataSource());
        dataSourceMap.put(DataSourceType.SLAVE, slaveDataSource());
        
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());
        
        return dynamicDataSource;
    }
    
    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean();
        factoryBean.setDataSource(dynamicDataSource());
        
        // 配置MyBatis Plus
        MybatisConfiguration configuration = new MybatisConfiguration();
        configuration.addInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        configuration.addInterceptor(new OptimisticLockerInnerInterceptor());
        configuration.addInterceptor(new BlockAttackInnerInterceptor());
        
        factoryBean.setConfiguration(configuration);
        return factoryBean.getObject();
    }
}

public class DynamicRoutingDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}

public class DataSourceContextHolder {
    
    private static final ThreadLocal<DataSourceType> CONTEXT_HOLDER = new ThreadLocal<>();
    
    public static void setDataSourceType(DataSourceType dataSourceType) {
        CONTEXT_HOLDER.set(dataSourceType);
    }
    
    public static DataSourceType getDataSourceType() {
        return CONTEXT_HOLDER.get();
    }
    
    public static void clearDataSourceType() {
        CONTEXT_HOLDER.remove();
    }
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    DataSourceType value() default DataSourceType.MASTER;
}

public enum DataSourceType {
    MASTER, SLAVE
}
```

#### 2. 读写分离AOP

```java
@Aspect
@Component
@Slf4j
public class DataSourceAspect {
    
    @Pointcut("@annotation(com.cloudDemo.common.annotation.DataSource)")
    public void dataSourcePointcut() {}
    
    @Around("dataSourcePointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        
        DataSource dataSource = method.getAnnotation(DataSource.class);
        if (dataSource == null) {
            dataSource = point.getTarget().getClass().getAnnotation(DataSource.class);
        }
        
        DataSourceType dataSourceType = DataSourceType.MASTER;
        if (dataSource != null) {
            dataSourceType = dataSource.value();
        } else {
            // 自动选择数据源：查询操作使用从库，其他操作使用主库
            String methodName = method.getName();
            if (methodName.startsWith("select") || methodName.startsWith("get") 
                || methodName.startsWith("find") || methodName.startsWith("list")
                || methodName.startsWith("count") || methodName.startsWith("query")) {
                dataSourceType = DataSourceType.SLAVE;
            }
        }
        
        DataSourceContextHolder.setDataSourceType(dataSourceType);
        log.debug("切换数据源: {} -> {}", method.getName(), dataSourceType);
        
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clearDataSourceType();
        }
    }
}
```

---

## 🎯 实施建议

### 第一阶段：基础深化 (1周)

1. **Nacos高级特性**: 命名空间、配置加密、权限控制
2. **Redis分布式锁**: 可重入锁、锁续期机制
3. **MyBatis Plus扩展**: 自动填充、多数据源

### 第二阶段：中间件深化 (1周)

1. **Dubbo SPI扩展**: 自定义负载均衡、过滤器
2. **Sentinel进阶**: 热点参数限流、系统保护
3. **Gateway增强**: 自定义过滤器、动态路由

### 第三阶段：架构优化 (1周)

1. **消息队列**: Redis可靠消息队列
2. **监控告警**: 自定义指标采集
3. **性能调优**: 连接池优化、缓存策略

通过这些深度应用，CloudDemo项目将展现出对微服务技术栈的深入理解和实践能力，为面试加分不少。
