# CloudDemo å¾®æœåŠ¡å„ç»„ä»¶æ·±åº¦ä½¿ç”¨æ–¹æ¡ˆ

## ğŸ¯ æ·±åº¦ä½¿ç”¨ç›®æ ‡

åœ¨ç°æœ‰CloudDemoé¡¹ç›®åŸºç¡€ä¸Šï¼Œæ·±å…¥æŒ–æ˜å„ä¸ªæŠ€æœ¯ç»„ä»¶çš„é«˜çº§ç‰¹æ€§å’Œæœ€ä½³å®è·µï¼Œæå‡æŠ€æœ¯æ·±åº¦å’Œé¢è¯•ç«äº‰åŠ›ï¼š

- **Nacosé«˜çº§ç‰¹æ€§**: å‘½åç©ºé—´ã€é…ç½®åŠ å¯†ã€æƒé™æ§åˆ¶
- **Dubboæ·±åº¦åº”ç”¨**: è‡ªå®šä¹‰è´Ÿè½½å‡è¡¡ã€SPIæ‰©å±•ã€åè®®ä¼˜åŒ–
- **Sentinelè¿›é˜¶åŠŸèƒ½**: çƒ­ç‚¹å‚æ•°é™æµã€ç³»ç»Ÿè‡ªé€‚åº”ä¿æŠ¤ã€é›†ç¾¤æµæ§
- **Spring Cloud Gatewayå¢å¼º**: è‡ªå®šä¹‰è¿‡æ»¤å™¨ã€é™æµç†”æ–­ã€å®‰å…¨è®¤è¯
- **Redisé«˜çº§åº”ç”¨**: åˆ†å¸ƒå¼é”ã€æ¶ˆæ¯é˜Ÿåˆ—ã€æ•°æ®ç»“æ„ä¼˜åŒ–
- **MyBatis Plusæ‰©å±•**: è‡ªå®šä¹‰å­—æ®µå¡«å……ã€å¤šæ•°æ®æºã€æ€§èƒ½ä¼˜åŒ–

## ğŸ—ï¸ Nacos é«˜çº§ç‰¹æ€§åº”ç”¨

### å‘½åç©ºé—´å¤šç¯å¢ƒéš”ç¦»

#### 1. å‘½åç©ºé—´é…ç½®

```java
@Configuration
public class NacosNamespaceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.cloud.nacos.discovery")
    public NacosDiscoveryProperties nacosDiscoveryProperties() {
        NacosDiscoveryProperties properties = new NacosDiscoveryProperties();
        
        // æ ¹æ®ç¯å¢ƒåŠ¨æ€è®¾ç½®å‘½åç©ºé—´
        String activeProfile = environment.getActiveProfiles()[0];
        switch (activeProfile) {
            case "dev":
                properties.setNamespace("dev-namespace-id");
                break;
            case "test":
                properties.setNamespace("test-namespace-id");
                break;
            case "prod":
                properties.setNamespace("prod-namespace-id");
                break;
            default:
                properties.setNamespace("public");
        }
        
        return properties;
    }
}
```

#### 2. é…ç½®åŠ å¯†è§£å¯†

```java
@Component
@Slf4j
public class ConfigDecryptProcessor implements ApplicationRunner {
    
    @Autowired
    private NacosConfigManager nacosConfigManager;
    
    @Autowired
    private AESUtil aesUtil;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // è·å–åŠ å¯†é…ç½®å¹¶è§£å¯†
        String encryptedConfig = nacosConfigManager.getConfigService()
            .getConfig("encrypted-config.properties", "DEFAULT_GROUP", 5000);
        
        if (StringUtils.hasText(encryptedConfig)) {
            Properties decryptedProps = decryptProperties(encryptedConfig);
            // å°†è§£å¯†åçš„é…ç½®æ³¨å…¥åˆ°ç¯å¢ƒä¸­
            MutablePropertySources propertySources = environment.getPropertySources();
            propertySources.addFirst(new PropertiesPropertySource("decrypted-config", decryptedProps));
        }
    }
    
    private Properties decryptProperties(String encryptedConfig) {
        Properties properties = new Properties();
        String[] lines = encryptedConfig.split("\n");
        
        for (String line : lines) {
            if (line.contains("=") && line.startsWith("ENC(")) {
                String[] parts = line.split("=", 2);
                String key = parts[0];
                String encryptedValue = parts[1];
                
                // è§£å¯†å€¼
                String decryptedValue = aesUtil.decrypt(
                    encryptedValue.substring(4, encryptedValue.length() - 1));
                
                properties.setProperty(key, decryptedValue);
                log.info("é…ç½®è§£å¯†æˆåŠŸ: {}", key);
            }
        }
        
        return properties;
    }
}
```

### é…ç½®å˜æ›´ç›‘å¬ä¸ç°åº¦å‘å¸ƒ

#### 1. é…ç½®å˜æ›´ç›‘å¬å™¨

```java
@Component
@Slf4j
public class DynamicConfigListener {
    
    @Autowired
    private ConfigurableApplicationContext applicationContext;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @NacosConfigListener(dataId = "dynamic-config.properties", groupId = "DEFAULT_GROUP")
    public void onConfigChange(String configInfo) {
        log.info("æ£€æµ‹åˆ°é…ç½®å˜æ›´: {}", configInfo);
        
        try {
            // è§£ææ–°é…ç½®
            Properties newProperties = parseProperties(configInfo);
            
            // éªŒè¯é…ç½®åˆæ³•æ€§
            validateConfiguration(newProperties);
            
            // ç°åº¦å‘å¸ƒé…ç½®
            performGrayReleaseConfig(newProperties);
            
            // åˆ·æ–°åº”ç”¨ä¸Šä¸‹æ–‡
            ContextRefresher contextRefresher = new ContextRefresher(applicationContext);
            contextRefresher.refresh();
            
            log.info("é…ç½®çƒ­æ›´æ–°æˆåŠŸ");
            
        } catch (Exception e) {
            log.error("é…ç½®çƒ­æ›´æ–°å¤±è´¥", e);
            // å‘é€å‘Šè­¦é€šçŸ¥
            sendConfigUpdateFailAlert(e.getMessage());
        }
    }
    
    private void performGrayReleaseConfig(Properties newProperties) {
        // ç°åº¦èŠ‚ç‚¹æ ‡è¯†
        String grayFlag = System.getProperty("gray.release", "false");
        
        if ("true".equals(grayFlag)) {
            // ç°åº¦èŠ‚ç‚¹å…ˆåº”ç”¨æ–°é…ç½®
            applyNewConfiguration(newProperties);
            
            // ç›‘æ§ç°åº¦èŠ‚ç‚¹å¥åº·çŠ¶å†µ
            monitorGrayNodeHealth();
            
            log.info("ç°åº¦é…ç½®å‘å¸ƒå®Œæˆ");
        } else {
            // ç­‰å¾…ç°åº¦éªŒè¯é€šè¿‡åå†åº”ç”¨
            waitForGrayValidation();
            applyNewConfiguration(newProperties);
        }
    }
}
```

## ğŸš€ Dubbo æ·±åº¦åº”ç”¨

### è‡ªå®šä¹‰è´Ÿè½½å‡è¡¡ç­–ç•¥

#### 1. æƒé‡è‡ªé€‚åº”è´Ÿè½½å‡è¡¡

```java
@SPI("adaptive_weight")
public class AdaptiveWeightLoadBalance extends AbstractLoadBalance {
    
    private final ConcurrentMap<String, WeightedRoundRobin> methodWeightMap = new ConcurrentHashMap<>();
    
    @Override
    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
        String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
        int length = invokers.size();
        
        boolean sameWeight = true;
        int[] weights = new int[length];
        int firstWeight = getWeight(invokers.get(0), invocation);
        int totalWeight = firstWeight;
        
        // è®¡ç®—æƒé‡å¹¶æ£€æµ‹æ˜¯å¦ç›¸åŒ
        for (int i = 1; i < length; i++) {
            int weight = getWeight(invokers.get(i), invocation);
            weights[i] = weight;
            totalWeight += weight;
            if (sameWeight && weight != firstWeight) {
                sameWeight = false;
            }
        }
        
        WeightedRoundRobin wrr = methodWeightMap.computeIfAbsent(key, k -> new WeightedRoundRobin());
        
        if (totalWeight > 0 && !sameWeight) {
            return selectByWeight(invokers, weights, totalWeight, wrr);
        }
        
        // æƒé‡ç›¸åŒæ—¶ä½¿ç”¨è½®è¯¢
        return invokers.get((int) (wrr.incrementAndGet() % length));
    }
    
    private <T> Invoker<T> selectByWeight(List<Invoker<T>> invokers, int[] weights, 
                                         int totalWeight, WeightedRoundRobin wrr) {
        int offset = (int) (wrr.incrementAndGet() % totalWeight);
        for (int i = 0; i < weights.length; i++) {
            offset -= weights[i];
            if (offset < 0) {
                return invokers.get(i);
            }
        }
        return invokers.get(0);
    }
    
    protected int getWeight(Invoker<?> invoker, Invocation invocation) {
        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), "weight", 100);
        
        // æ ¹æ®å“åº”æ—¶é—´åŠ¨æ€è°ƒæ•´æƒé‡
        long avgResponseTime = getAverageResponseTime(invoker);
        if (avgResponseTime > 0) {
            // å“åº”æ—¶é—´è¶Šé•¿ï¼Œæƒé‡è¶Šä½
            weight = (int) (weight * (1000.0 / (avgResponseTime + 1000)));
        }
        
        return Math.max(weight, 1);
    }
    
    private long getAverageResponseTime(Invoker<?> invoker) {
        // ä»ç›‘æ§æ•°æ®ä¸­è·å–å¹³å‡å“åº”æ—¶é—´
        RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), 
            RpcContext.getContext().getMethodName());
        return rpcStatus.getAverageElapsed();
    }
}
```

#### 2. è‡ªå®šä¹‰è¿‡æ»¤å™¨

```java
@Activate(group = {CONSUMER, PROVIDER})
public class PerformanceMonitorFilter implements Filter {
    
    private static final Logger logger = LoggerFactory.getLogger(PerformanceMonitorFilter.class);
    
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        long startTime = System.currentTimeMillis();
        String methodName = invocation.getMethodName();
        String serviceName = invoker.getUrl().getServiceInterface();
        
        try {
            Result result = invoker.invoke(invocation);
            
            long elapsed = System.currentTimeMillis() - startTime;
            recordPerformanceMetrics(serviceName, methodName, elapsed, true);
            
            // æ…¢è°ƒç”¨å‘Šè­¦
            if (elapsed > getSlowCallThreshold(serviceName, methodName)) {
                logger.warn("æ£€æµ‹åˆ°æ…¢è°ƒç”¨: {}#{}, è€—æ—¶: {}ms", serviceName, methodName, elapsed);
                sendSlowCallAlert(serviceName, methodName, elapsed);
            }
            
            return result;
            
        } catch (Exception e) {
            long elapsed = System.currentTimeMillis() - startTime;
            recordPerformanceMetrics(serviceName, methodName, elapsed, false);
            
            logger.error("RPCè°ƒç”¨å¼‚å¸¸: {}#{}", serviceName, methodName, e);
            throw e;
        }
    }
    
    private void recordPerformanceMetrics(String serviceName, String methodName, 
                                        long elapsed, boolean success) {
        // è®°å½•åˆ°ç›‘æ§ç³»ç»Ÿ
        MetricRegistry.timer(serviceName + "." + methodName + ".timer")
            .update(elapsed, TimeUnit.MILLISECONDS);
        
        if (success) {
            MetricRegistry.counter(serviceName + "." + methodName + ".success").inc();
        } else {
            MetricRegistry.counter(serviceName + "." + methodName + ".error").inc();
        }
    }
}
```

### SPI æ‰©å±•æœºåˆ¶

#### 1. è‡ªå®šä¹‰æ³¨å†Œä¸­å¿ƒæ‰©å±•

```java
@SPI("consul")
public class ConsulRegistry extends AbstractRegistry {
    
    private final ConsulClient consulClient;
    private final ScheduledExecutorService heartbeatExecutor;
    
    public ConsulRegistry(URL url) {
        super(url);
        this.consulClient = new ConsulClient(url.getHost(), url.getPort());
        this.heartbeatExecutor = Executors.newScheduledThreadPool(1);
        startHeartbeat();
    }
    
    @Override
    public void doRegister(URL url) {
        try {
            NewService newService = new NewService();
            newService.setId(buildServiceId(url));
            newService.setName(url.getServiceInterface());
            newService.setAddress(url.getHost());
            newService.setPort(url.getPort());
            
            // å¥åº·æ£€æŸ¥é…ç½®
            NewService.Check check = new NewService.Check();
            check.setHttp("http://" + url.getHost() + ":" + url.getPort() + "/health");
            check.setInterval("10s");
            check.setTimeout("3s");
            newService.setCheck(check);
            
            consulClient.agentServiceRegister(newService);
            logger.info("æœåŠ¡æ³¨å†ŒæˆåŠŸ: {}", url);
            
        } catch (Exception e) {
            throw new RpcException("æ³¨å†ŒæœåŠ¡å¤±è´¥: " + url, e);
        }
    }
    
    @Override
    public void doUnregister(URL url) {
        try {
            consulClient.agentServiceDeregister(buildServiceId(url));
            logger.info("æœåŠ¡æ³¨é”€æˆåŠŸ: {}", url);
        } catch (Exception e) {
            logger.warn("æ³¨é”€æœåŠ¡å¤±è´¥: " + url, e);
        }
    }
    
    @Override
    public void doSubscribe(URL url, NotifyListener listener) {
        // å®ç°æœåŠ¡å‘ç°é€»è¾‘
        List<HealthService> healthServices = consulClient.getHealthServices(
            url.getServiceInterface(), true, null).getValue();
        
        List<URL> urls = healthServices.stream()
            .map(service -> buildProviderUrl(service))
            .collect(Collectors.toList());
        
        listener.notify(urls);
    }
}
```

## âš¡ Sentinel è¿›é˜¶åŠŸèƒ½

### çƒ­ç‚¹å‚æ•°é™æµ

#### 1. çƒ­ç‚¹å‚æ•°é…ç½®

```java
@RestController
@RequestMapping("/products")
public class ProductController {
    
    @GetMapping("/{productId}")
    @SentinelResource(value = "getProduct", blockHandler = "handleProductBlock")
    public ResponseEntity<Product> getProduct(
            @PathVariable("productId") Long productId,
            @RequestParam(defaultValue = "1") Integer version) {
        
        // ä¸šåŠ¡é€»è¾‘
        Product product = productService.getById(productId);
        return ResponseEntity.ok(product);
    }
    
    public ResponseEntity<Product> handleProductBlock(Long productId, Integer version, 
                                                     BlockException ex) {
        // çƒ­ç‚¹å•†å“é™çº§å¤„ç†
        Product cachedProduct = productService.getFromCache(productId);
        if (cachedProduct != null) {
            return ResponseEntity.ok(cachedProduct);
        }
        
        return ResponseEntity.status(429)
            .body(Product.builder().id(productId).name("å•†å“è®¿é—®è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•").build());
    }
}

@Configuration
public class SentinelHotParamConfig {
    
    @PostConstruct
    public void initHotParamRules() {
        List<ParamFlowRule> rules = new ArrayList<>();
        
        // é…ç½®å•†å“IDçƒ­ç‚¹å‚æ•°é™æµ
        ParamFlowRule rule = new ParamFlowRule();
        rule.setResource("getProduct");
        rule.setParamIdx(0); // ç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆproductIdï¼‰
        rule.setCount(10);   // QPSé™åˆ¶
        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
        
        // çƒ­ç‚¹å•†å“ç‰¹æ®Šé…ç½®
        Map<Object, Integer> paramMap = new HashMap<>();
        paramMap.put(1001L, 50);  // çƒ­é—¨å•†å“ID=1001ï¼ŒQPS=50
        paramMap.put(1002L, 30);  // çƒ­é—¨å•†å“ID=1002ï¼ŒQPS=30
        rule.setParamFlowItemList(paramMap.entrySet().stream()
            .map(entry -> new ParamFlowItem()
                .setObject(entry.getKey().toString())
                .setClassType(Long.class.getName())
                .setCount(entry.getValue()))
            .collect(Collectors.toList()));
        
        rules.add(rule);
        ParamFlowRuleManager.loadRules(rules);
    }
}
```

### ç³»ç»Ÿè‡ªé€‚åº”ä¿æŠ¤

#### 1. è‡ªé€‚åº”é™æµé…ç½®

```java
@Configuration
public class SentinelSystemConfig {
    
    @PostConstruct
    public void initSystemRules() {
        List<SystemRule> rules = new ArrayList<>();
        
        // CPUä½¿ç”¨ç‡ä¿æŠ¤
        SystemRule cpuRule = new SystemRule();
        cpuRule.setHighestCpuUsage(0.8); // CPUä½¿ç”¨ç‡è¶…è¿‡80%æ—¶é™æµ
        rules.add(cpuRule);
        
        // ç³»ç»Ÿè´Ÿè½½ä¿æŠ¤
        SystemRule loadRule = new SystemRule();
        loadRule.setHighestSystemLoad(10.0); // ç³»ç»Ÿè´Ÿè½½è¶…è¿‡10æ—¶é™æµ
        rules.add(loadRule);
        
        // å¹³å‡å“åº”æ—¶é—´ä¿æŠ¤
        SystemRule rtRule = new SystemRule();
        rtRule.setAvgRt(1000); // å¹³å‡å“åº”æ—¶é—´è¶…è¿‡1ç§’æ—¶é™æµ
        rules.add(rtRule);
        
        // å¹¶å‘çº¿ç¨‹æ•°ä¿æŠ¤
        SystemRule threadRule = new SystemRule();
        threadRule.setMaxThread(100); // å¹¶å‘çº¿ç¨‹æ•°è¶…è¿‡100æ—¶é™æµ
        rules.add(threadRule);
        
        SystemRuleManager.loadRules(rules);
    }
}
```

#### 2. è‡ªå®šä¹‰ç³»ç»ŸæŒ‡æ ‡é‡‡é›†

```java
@Component
@Slf4j
public class CustomSystemMetricCollector {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Scheduled(fixedRate = 1000) // æ¯ç§’é‡‡é›†ä¸€æ¬¡
    public void collectMetrics() {
        // é‡‡é›†JVMæŒ‡æ ‡
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        double memoryUsage = (double) usedMemory / totalMemory;
        meterRegistry.gauge("jvm.memory.usage", memoryUsage);
        
        // é‡‡é›†æ•°æ®åº“è¿æ¥æ± æŒ‡æ ‡
        HikariDataSource dataSource = getDataSource();
        if (dataSource != null) {
            HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();
            meterRegistry.gauge("hikari.connections.active", poolBean.getActiveConnections());
            meterRegistry.gauge("hikari.connections.idle", poolBean.getIdleConnections());
            meterRegistry.gauge("hikari.connections.total", poolBean.getTotalConnections());
        }
        
        // é‡‡é›†Redisè¿æ¥æŒ‡æ ‡
        LettuceConnectionFactory redisFactory = getRedisConnectionFactory();
        if (redisFactory != null) {
            // è·å–Redisè¿æ¥çŠ¶æ€
            meterRegistry.gauge("redis.connections.active", getActiveRedisConnections());
        }
    }
    
    @EventListener
    public void handleSystemOverload(SystemOverloadEvent event) {
        log.warn("ç³»ç»Ÿè¿‡è½½æ£€æµ‹: {}", event.getMetricType());
        
        switch (event.getMetricType()) {
            case CPU:
                handleCpuOverload(event.getValue());
                break;
            case MEMORY:
                handleMemoryOverload(event.getValue());
                break;
            case LOAD:
                handleLoadOverload(event.getValue());
                break;
        }
    }
}
```

## ğŸŒ Spring Cloud Gateway å¢å¼º

### è‡ªå®šä¹‰å…¨å±€è¿‡æ»¤å™¨

#### 1. è¯·æ±‚è¿½è¸ªè¿‡æ»¤å™¨

```java
@Component
@Slf4j
public class RequestTrackingGlobalFilter implements GlobalFilter, Ordered {
    
    private static final String TRACE_ID_HEADER = "X-Trace-Id";
    private static final String START_TIME_ATTR = "startTime";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String traceId = getOrGenerateTraceId(request);
        
        // è®¾ç½®è¿½è¸ªä¸Šä¸‹æ–‡
        exchange.getAttributes().put(START_TIME_ATTR, System.currentTimeMillis());
        
        // ä¿®æ”¹è¯·æ±‚å¤´ï¼Œæ·»åŠ è¿½è¸ªID
        ServerHttpRequest modifiedRequest = request.mutate()
            .header(TRACE_ID_HEADER, traceId)
            .build();
        
        ServerWebExchange modifiedExchange = exchange.mutate()
            .request(modifiedRequest)
            .build();
        
        return chain.filter(modifiedExchange)
            .doFinally(signalType -> {
                // è®°å½•è¯·æ±‚å®Œæˆä¿¡æ¯
                long startTime = (Long) exchange.getAttributes().get(START_TIME_ATTR);
                long duration = System.currentTimeMillis() - startTime;
                
                logRequestCompletion(request, traceId, duration, signalType);
            });
    }
    
    private String getOrGenerateTraceId(ServerHttpRequest request) {
        String traceId = request.getHeaders().getFirst(TRACE_ID_HEADER);
        return StringUtils.hasText(traceId) ? traceId : generateTraceId();
    }
    
    private String generateTraceId() {
        return UUID.randomUUID().toString().replace("-", "");
    }
    
    private void logRequestCompletion(ServerHttpRequest request, String traceId, 
                                    long duration, SignalType signalType) {
        log.info("è¯·æ±‚å®Œæˆ - TraceId: {}, Method: {}, URI: {}, Duration: {}ms, Signal: {}", 
            traceId, request.getMethod(), request.getURI(), duration, signalType);
        
        // è®°å½•åˆ°ç›‘æ§ç³»ç»Ÿ
        Metrics.timer("gateway.request.duration", 
            "method", request.getMethod().name(),
            "path", request.getPath().toString())
            .record(duration, TimeUnit.MILLISECONDS);
    }
    
    @Override
    public int getOrder() {
        return -1; // æœ€é«˜ä¼˜å…ˆçº§
    }
}
```

#### 2. æ™ºèƒ½é™æµè¿‡æ»¤å™¨

```java
@Component
public class IntelligentRateLimitGatewayFilter implements GatewayFilter, Ordered {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private UserBehaviorAnalyzer userBehaviorAnalyzer;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return determineRateLimit(exchange)
            .flatMap(rateLimit -> {
                if (rateLimit.isAllowed()) {
                    return chain.filter(exchange);
                } else {
                    return handleRateLimitExceeded(exchange, rateLimit);
                }
            });
    }
    
    private Mono<RateLimitResult> determineRateLimit(ServerWebExchange exchange) {
        return Mono.fromCallable(() -> {
            String clientId = getClientId(exchange.getRequest());
            String path = exchange.getRequest().getPath().toString();
            
            // åŸºäºç”¨æˆ·è¡Œä¸ºçš„åŠ¨æ€é™æµ
            UserBehavior behavior = userBehaviorAnalyzer.analyze(clientId);
            RateLimitConfig config = buildRateLimitConfig(behavior, path);
            
            return executeRateLimit(clientId, path, config);
        }).subscribeOn(Schedulers.boundedElastic());
    }
    
    private RateLimitConfig buildRateLimitConfig(UserBehavior behavior, String path) {
        RateLimitConfig config = new RateLimitConfig();
        
        // æ ¹æ®ç”¨æˆ·ç­‰çº§è°ƒæ•´é™æµç­–ç•¥
        switch (behavior.getUserLevel()) {
            case VIP:
                config.setRequestsPerSecond(100);
                config.setBurstCapacity(200);
                break;
            case NORMAL:
                config.setRequestsPerSecond(50);
                config.setBurstCapacity(100);
                break;
            case SUSPICIOUS:
                config.setRequestsPerSecond(10);
                config.setBurstCapacity(20);
                break;
        }
        
        // æ ¹æ®è·¯å¾„ç±»å‹è°ƒæ•´
        if (path.startsWith("/api/public")) {
            config.setRequestsPerSecond(config.getRequestsPerSecond() * 2);
        } else if (path.startsWith("/api/admin")) {
            config.setRequestsPerSecond(config.getRequestsPerSecond() / 2);
        }
        
        return config;
    }
    
    private RateLimitResult executeRateLimit(String clientId, String path, RateLimitConfig config) {
        String key = "rate_limit:" + clientId + ":" + path;
        
        // ä½¿ç”¨ä»¤ç‰Œæ¡¶ç®—æ³•
        return TokenBucketRateLimiter.builder()
            .redisTemplate(redisTemplate)
            .key(key)
            .capacity(config.getBurstCapacity())
            .refillRate(config.getRequestsPerSecond())
            .build()
            .tryAcquire();
    }
}
```

### åŠ¨æ€è·¯ç”±ç®¡ç†

#### 1. è·¯ç”±é…ç½®ç®¡ç†å™¨

```java
@Component
@Slf4j
public class DynamicRouteManager {
    
    @Autowired
    private RouteDefinitionWriter routeDefinitionWriter;
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @Autowired
    private RouteDefinitionRepository routeDefinitionRepository;
    
    /**
     * åŠ¨æ€æ·»åŠ è·¯ç”±
     */
    public Mono<ResponseEntity<String>> addRoute(RouteDefinition routeDefinition) {
        return routeDefinitionWriter.save(Mono.just(routeDefinition))
            .then(Mono.defer(() -> {
                // å‘å¸ƒè·¯ç”±åˆ·æ–°äº‹ä»¶
                eventPublisher.publishEvent(new RefreshRoutesEvent(this));
                log.info("åŠ¨æ€è·¯ç”±æ·»åŠ æˆåŠŸ: {}", routeDefinition.getId());
                return Mono.just(ResponseEntity.ok("è·¯ç”±æ·»åŠ æˆåŠŸ"));
            }))
            .onErrorResume(ex -> {
                log.error("åŠ¨æ€è·¯ç”±æ·»åŠ å¤±è´¥", ex);
                return Mono.just(ResponseEntity.badRequest().body("è·¯ç”±æ·»åŠ å¤±è´¥: " + ex.getMessage()));
            });
    }
    
    /**
     * åŠ¨æ€åˆ é™¤è·¯ç”±
     */
    public Mono<ResponseEntity<String>> removeRoute(String routeId) {
        return routeDefinitionWriter.delete(Mono.just(routeId))
            .then(Mono.defer(() -> {
                eventPublisher.publishEvent(new RefreshRoutesEvent(this));
                log.info("åŠ¨æ€è·¯ç”±åˆ é™¤æˆåŠŸ: {}", routeId);
                return Mono.just(ResponseEntity.ok("è·¯ç”±åˆ é™¤æˆåŠŸ"));
            }))
            .onErrorResume(ex -> {
                log.error("åŠ¨æ€è·¯ç”±åˆ é™¤å¤±è´¥", ex);
                return Mono.just(ResponseEntity.badRequest().body("è·¯ç”±åˆ é™¤å¤±è´¥: " + ex.getMessage()));
            });
    }
    
    /**
     * åŸºäºæœåŠ¡å¥åº·çŠ¶æ€çš„è·¯ç”±åˆ‡æ¢
     */
    @EventListener
    public void handleServiceHealthChange(ServiceHealthChangeEvent event) {
        if (!event.isHealthy()) {
            log.warn("æ£€æµ‹åˆ°æœåŠ¡ä¸å¥åº·ï¼Œå‡†å¤‡åˆ‡æ¢è·¯ç”±: {}", event.getServiceName());
            
            // è·å–å¤‡ç”¨æœåŠ¡è·¯ç”±
            RouteDefinition backupRoute = getBackupRoute(event.getServiceName());
            if (backupRoute != null) {
                addRoute(backupRoute).subscribe();
            }
            
            // ç¦ç”¨ä¸å¥åº·çš„æœåŠ¡è·¯ç”±
            disableRoute(event.getServiceName());
        } else {
            log.info("æœåŠ¡æ¢å¤å¥åº·ï¼Œæ¢å¤åŸå§‹è·¯ç”±: {}", event.getServiceName());
            enableRoute(event.getServiceName());
        }
    }
}
```

## ğŸ”´ Redis é«˜çº§åº”ç”¨

### åˆ†å¸ƒå¼é”å®ç°

#### 1. å¯é‡å…¥åˆ†å¸ƒå¼é”

```java
@Component
@Slf4j
public class RedisDistributedLock {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String LOCK_PREFIX = "distributed_lock:";
    private static final String REENTRANT_PREFIX = "reentrant:";
    private static final ThreadLocal<Map<String, Integer>> LOCK_COUNT_MAP = new ThreadLocal<>();
    
    /**
     * å°è¯•è·å–é”
     */
    public boolean tryLock(String key, long expireTime, TimeUnit timeUnit) {
        String lockKey = LOCK_PREFIX + key;
        String reentrantKey = REENTRANT_PREFIX + key;
        String threadId = getThreadId();
        
        // æ£€æŸ¥é‡å…¥
        Map<String, Integer> lockCountMap = LOCK_COUNT_MAP.get();
        if (lockCountMap == null) {
            lockCountMap = new HashMap<>();
            LOCK_COUNT_MAP.set(lockCountMap);
        }
        
        Integer count = lockCountMap.get(key);
        if (count != null && count > 0) {
            // é‡å…¥é”
            lockCountMap.put(key, count + 1);
            redisTemplate.opsForValue().increment(reentrantKey);
            return true;
        }
        
        // å°è¯•è·å–æ–°é”
        Boolean success = redisTemplate.opsForValue().setIfAbsent(
            lockKey, threadId, expireTime, timeUnit);
        
        if (success != null && success) {
            lockCountMap.put(key, 1);
            redisTemplate.opsForValue().set(reentrantKey, "1", expireTime, timeUnit);
            
            // å¯åŠ¨é”ç»­æœŸä»»åŠ¡
            startLockRenewal(lockKey, threadId, expireTime, timeUnit);
            return true;
        }
        
        return false;
    }
    
    /**
     * é‡Šæ”¾é”
     */
    public boolean unlock(String key) {
        String lockKey = LOCK_PREFIX + key;
        String reentrantKey = REENTRANT_PREFIX + key;
        String threadId = getThreadId();
        
        Map<String, Integer> lockCountMap = LOCK_COUNT_MAP.get();
        if (lockCountMap == null) {
            return false;
        }
        
        Integer count = lockCountMap.get(key);
        if (count == null || count <= 0) {
            return false;
        }
        
        if (count > 1) {
            // é‡å…¥é”è®¡æ•°é€’å‡
            lockCountMap.put(key, count - 1);
            redisTemplate.opsForValue().decrement(reentrantKey);
            return true;
        }
        
        // é‡Šæ”¾é”
        String luaScript = """
            if redis.call('GET', KEYS[1]) == ARGV[1] then
                redis.call('DEL', KEYS[1])
                redis.call('DEL', KEYS[2])
                return 1
            else
                return 0
            end
            """;
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(luaScript);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(redisScript, 
            Arrays.asList(lockKey, reentrantKey), threadId);
        
        if (result != null && result == 1) {
            lockCountMap.remove(key);
            stopLockRenewal(lockKey);
            return true;
        }
        
        return false;
    }
    
    /**
     * é”ç»­æœŸæœºåˆ¶
     */
    private void startLockRenewal(String lockKey, String threadId, long expireTime, TimeUnit timeUnit) {
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        long renewalInterval = timeUnit.toMillis(expireTime) / 3; // æ¯1/3è¿‡æœŸæ—¶é—´ç»­æœŸä¸€æ¬¡
        
        ScheduledFuture<?> renewalTask = scheduler.scheduleAtFixedRate(() -> {
            try {
                String luaScript = """
                    if redis.call('GET', KEYS[1]) == ARGV[1] then
                        return redis.call('EXPIRE', KEYS[1], ARGV[2])
                    else
                        return 0
                    end
                    """;
                
                DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
                redisScript.setScriptText(luaScript);
                redisScript.setResultType(Long.class);
                
                Long result = redisTemplate.execute(redisScript, 
                    Collections.singletonList(lockKey), 
                    threadId, String.valueOf(timeUnit.toSeconds(expireTime)));
                
                if (result == null || result == 0) {
                    log.warn("é”ç»­æœŸå¤±è´¥ï¼Œåœæ­¢ç»­æœŸä»»åŠ¡: {}", lockKey);
                    throw new RuntimeException("é”å·²è¿‡æœŸæˆ–è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰");
                }
                
                log.debug("é”ç»­æœŸæˆåŠŸ: {}", lockKey);
                
            } catch (Exception e) {
                log.error("é”ç»­æœŸå¼‚å¸¸: " + lockKey, e);
                throw new RuntimeException(e);
            }
        }, renewalInterval, renewalInterval, TimeUnit.MILLISECONDS);
        
        // ä¿å­˜ç»­æœŸä»»åŠ¡ä»¥ä¾¿åç»­å–æ¶ˆ
        RENEWAL_TASKS.put(lockKey, renewalTask);
    }
    
    private static final Map<String, ScheduledFuture<?>> RENEWAL_TASKS = new ConcurrentHashMap<>();
    
    private void stopLockRenewal(String lockKey) {
        ScheduledFuture<?> renewalTask = RENEWAL_TASKS.remove(lockKey);
        if (renewalTask != null) {
            renewalTask.cancel(true);
            log.debug("åœæ­¢é”ç»­æœŸä»»åŠ¡: {}", lockKey);
        }
    }
    
    private String getThreadId() {
        return Thread.currentThread().getId() + "-" + System.nanoTime();
    }
}
```

### Redis æ¶ˆæ¯é˜Ÿåˆ—

#### 1. å¯é æ¶ˆæ¯é˜Ÿåˆ—å®ç°

```java
@Component
@Slf4j
public class RedisReliableMessageQueue {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String PENDING_QUEUE = "message:pending:";
    private static final String PROCESSING_QUEUE = "message:processing:";
    private static final String DEAD_LETTER_QUEUE = "message:dlq:";
    
    /**
     * å‘é€æ¶ˆæ¯
     */
    public void sendMessage(String topic, Object message) {
        ReliableMessage reliableMessage = ReliableMessage.builder()
            .id(UUID.randomUUID().toString())
            .topic(topic)
            .payload(message)
            .createTime(System.currentTimeMillis())
            .retryCount(0)
            .maxRetries(3)
            .build();
        
        String queueKey = PENDING_QUEUE + topic;
        redisTemplate.opsForList().leftPush(queueKey, reliableMessage);
        
        log.info("æ¶ˆæ¯å‘é€æˆåŠŸ: topic={}, messageId={}", topic, reliableMessage.getId());
    }
    
    /**
     * æ¶ˆè´¹æ¶ˆæ¯
     */
    @Async
    public void consumeMessages(String topic, MessageHandler handler) {
        String pendingKey = PENDING_QUEUE + topic;
        String processingKey = PROCESSING_QUEUE + topic;
        
        while (!Thread.currentThread().isInterrupted()) {
            try {
                // ä»å¾…å¤„ç†é˜Ÿåˆ—ç§»åŠ¨åˆ°å¤„ç†é˜Ÿåˆ—
                Object messageObj = redisTemplate.opsForList()
                    .rightPopAndLeftPush(pendingKey, processingKey);
                
                if (messageObj == null) {
                    Thread.sleep(100); // é˜Ÿåˆ—ä¸ºç©ºæ—¶ç­‰å¾…
                    continue;
                }
                
                ReliableMessage message = (ReliableMessage) messageObj;
                
                try {
                    // å¤„ç†æ¶ˆæ¯
                    handler.handle(message);
                    
                    // å¤„ç†æˆåŠŸï¼Œä»å¤„ç†é˜Ÿåˆ—ä¸­ç§»é™¤
                    redisTemplate.opsForList().remove(processingKey, 1, message);
                    
                    log.info("æ¶ˆæ¯å¤„ç†æˆåŠŸ: messageId={}", message.getId());
                    
                } catch (Exception e) {
                    log.error("æ¶ˆæ¯å¤„ç†å¤±è´¥: messageId=" + message.getId(), e);
                    handleMessageFailure(topic, message, e);
                }
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("æ¶ˆæ¯æ¶ˆè´¹å¼‚å¸¸", e);
            }
        }
    }
    
    /**
     * å¤„ç†æ¶ˆæ¯å¤±è´¥
     */
    private void handleMessageFailure(String topic, ReliableMessage message, Exception e) {
        String processingKey = PROCESSING_QUEUE + topic;
        String pendingKey = PENDING_QUEUE + topic;
        String dlqKey = DEAD_LETTER_QUEUE + topic;
        
        message.setRetryCount(message.getRetryCount() + 1);
        message.setLastError(e.getMessage());
        
        // ä»å¤„ç†é˜Ÿåˆ—ä¸­ç§»é™¤
        redisTemplate.opsForList().remove(processingKey, 1, message);
        
        if (message.getRetryCount() < message.getMaxRetries()) {
            // é‡æ–°æ”¾å…¥å¾…å¤„ç†é˜Ÿåˆ—
            redisTemplate.opsForList().leftPush(pendingKey, message);
            log.info("æ¶ˆæ¯é‡è¯•: messageId={}, retryCount={}", 
                message.getId(), message.getRetryCount());
        } else {
            // è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å…¥æ­»ä¿¡é˜Ÿåˆ—
            redisTemplate.opsForList().leftPush(dlqKey, message);
            log.warn("æ¶ˆæ¯å¤„ç†å¤±è´¥ï¼Œç§»å…¥æ­»ä¿¡é˜Ÿåˆ—: messageId={}", message.getId());
        }
    }
    
    /**
     * æ­»ä¿¡é˜Ÿåˆ—ç›‘æ§
     */
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    public void monitorDeadLetterQueue() {
        Set<String> topics = getTopics();
        
        for (String topic : topics) {
            String dlqKey = DEAD_LETTER_QUEUE + topic;
            Long size = redisTemplate.opsForList().size(dlqKey);
            
            if (size != null && size > 0) {
                log.warn("æ­»ä¿¡é˜Ÿåˆ—å‘ç°æ¶ˆæ¯: topic={}, count={}", topic, size);
                
                // å‘é€å‘Šè­¦
                sendDeadLetterAlert(topic, size);
            }
        }
    }
}
```

## ğŸ“Š MyBatis Plus æ‰©å±•

### è‡ªå®šä¹‰å­—æ®µå¡«å……

#### 1. å…ƒæ•°æ®å¯¹è±¡å¡«å……å™¨

```java
@Component
@Slf4j
public class CustomMetaObjectHandler implements MetaObjectHandler {
    
    @Override
    public void insertFill(MetaObject metaObject) {
        log.debug("å¼€å§‹æ’å…¥å¡«å……...");
        
        // è‡ªåŠ¨å¡«å……åˆ›å»ºæ—¶é—´
        this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
        this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        
        // è‡ªåŠ¨å¡«å……åˆ›å»ºäºº
        Long currentUserId = getCurrentUserId();
        if (currentUserId != null) {
            this.strictInsertFill(metaObject, "createBy", Long.class, currentUserId);
            this.strictInsertFill(metaObject, "updateBy", Long.class, currentUserId);
        }
        
        // è‡ªåŠ¨å¡«å……ç§Ÿæˆ·ID
        Long tenantId = getCurrentTenantId();
        if (tenantId != null) {
            this.strictInsertFill(metaObject, "tenantId", Long.class, tenantId);
        }
        
        // è‡ªåŠ¨å¡«å……ç‰ˆæœ¬å·
        this.strictInsertFill(metaObject, "version", Integer.class, 1);
        
        // è‡ªåŠ¨å¡«å……é€»è¾‘åˆ é™¤æ ‡è¯†
        this.strictInsertFill(metaObject, "deleted", Integer.class, 0);
    }
    
    @Override
    public void updateFill(MetaObject metaObject) {
        log.debug("å¼€å§‹æ›´æ–°å¡«å……...");
        
        // è‡ªåŠ¨å¡«å……æ›´æ–°æ—¶é—´
        this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
        
        // è‡ªåŠ¨å¡«å……æ›´æ–°äºº
        Long currentUserId = getCurrentUserId();
        if (currentUserId != null) {
            this.strictUpdateFill(metaObject, "updateBy", Long.class, currentUserId);
        }
    }
    
    private Long getCurrentUserId() {
        try {
            // ä»Securityä¸Šä¸‹æ–‡æˆ–ThreadLocalè·å–å½“å‰ç”¨æˆ·ID
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated()) {
                Object principal = authentication.getPrincipal();
                if (principal instanceof UserPrincipal) {
                    return ((UserPrincipal) principal).getId();
                }
            }
        } catch (Exception e) {
            log.warn("è·å–å½“å‰ç”¨æˆ·IDå¤±è´¥", e);
        }
        return null;
    }
    
    private Long getCurrentTenantId() {
        // ä»è¯·æ±‚å¤´æˆ–ä¸Šä¸‹æ–‡è·å–ç§Ÿæˆ·ID
        try {
            RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
            if (requestAttributes instanceof ServletRequestAttributes) {
                HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
                String tenantId = request.getHeader("X-Tenant-Id");
                return StringUtils.hasText(tenantId) ? Long.parseLong(tenantId) : null;
            }
        } catch (Exception e) {
            log.warn("è·å–å½“å‰ç§Ÿæˆ·IDå¤±è´¥", e);
        }
        return null;
    }
}
```

### å¤šæ•°æ®æºé…ç½®

#### 1. åŠ¨æ€æ•°æ®æºé…ç½®

```java
@Configuration
public class DynamicDataSourceConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.master")
    public DataSource masterDataSource() {
        return DruidDataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DruidDataSourceBuilder.create().build();
    }
    
    @Bean
    @Primary
    public DataSource dynamicDataSource() {
        DynamicRoutingDataSource dynamicDataSource = new DynamicRoutingDataSource();
        
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put(DataSourceType.MASTER, masterDataSource());
        dataSourceMap.put(DataSourceType.SLAVE, slaveDataSource());
        
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());
        
        return dynamicDataSource;
    }
    
    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean();
        factoryBean.setDataSource(dynamicDataSource());
        
        // é…ç½®MyBatis Plus
        MybatisConfiguration configuration = new MybatisConfiguration();
        configuration.addInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        configuration.addInterceptor(new OptimisticLockerInnerInterceptor());
        configuration.addInterceptor(new BlockAttackInnerInterceptor());
        
        factoryBean.setConfiguration(configuration);
        return factoryBean.getObject();
    }
}

public class DynamicRoutingDataSource extends AbstractRoutingDataSource {
    
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}

public class DataSourceContextHolder {
    
    private static final ThreadLocal<DataSourceType> CONTEXT_HOLDER = new ThreadLocal<>();
    
    public static void setDataSourceType(DataSourceType dataSourceType) {
        CONTEXT_HOLDER.set(dataSourceType);
    }
    
    public static DataSourceType getDataSourceType() {
        return CONTEXT_HOLDER.get();
    }
    
    public static void clearDataSourceType() {
        CONTEXT_HOLDER.remove();
    }
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    DataSourceType value() default DataSourceType.MASTER;
}

public enum DataSourceType {
    MASTER, SLAVE
}
```

#### 2. è¯»å†™åˆ†ç¦»AOP

```java
@Aspect
@Component
@Slf4j
public class DataSourceAspect {
    
    @Pointcut("@annotation(com.cloudDemo.common.annotation.DataSource)")
    public void dataSourcePointcut() {}
    
    @Around("dataSourcePointcut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        
        DataSource dataSource = method.getAnnotation(DataSource.class);
        if (dataSource == null) {
            dataSource = point.getTarget().getClass().getAnnotation(DataSource.class);
        }
        
        DataSourceType dataSourceType = DataSourceType.MASTER;
        if (dataSource != null) {
            dataSourceType = dataSource.value();
        } else {
            // è‡ªåŠ¨é€‰æ‹©æ•°æ®æºï¼šæŸ¥è¯¢æ“ä½œä½¿ç”¨ä»åº“ï¼Œå…¶ä»–æ“ä½œä½¿ç”¨ä¸»åº“
            String methodName = method.getName();
            if (methodName.startsWith("select") || methodName.startsWith("get") 
                || methodName.startsWith("find") || methodName.startsWith("list")
                || methodName.startsWith("count") || methodName.startsWith("query")) {
                dataSourceType = DataSourceType.SLAVE;
            }
        }
        
        DataSourceContextHolder.setDataSourceType(dataSourceType);
        log.debug("åˆ‡æ¢æ•°æ®æº: {} -> {}", method.getName(), dataSourceType);
        
        try {
            return point.proceed();
        } finally {
            DataSourceContextHolder.clearDataSourceType();
        }
    }
}
```

---

## ğŸ¯ å®æ–½å»ºè®®

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ·±åŒ– (1å‘¨)

1. **Nacosé«˜çº§ç‰¹æ€§**: å‘½åç©ºé—´ã€é…ç½®åŠ å¯†ã€æƒé™æ§åˆ¶
2. **Redisåˆ†å¸ƒå¼é”**: å¯é‡å…¥é”ã€é”ç»­æœŸæœºåˆ¶
3. **MyBatis Plusæ‰©å±•**: è‡ªåŠ¨å¡«å……ã€å¤šæ•°æ®æº

### ç¬¬äºŒé˜¶æ®µï¼šä¸­é—´ä»¶æ·±åŒ– (1å‘¨)

1. **Dubbo SPIæ‰©å±•**: è‡ªå®šä¹‰è´Ÿè½½å‡è¡¡ã€è¿‡æ»¤å™¨
2. **Sentinelè¿›é˜¶**: çƒ­ç‚¹å‚æ•°é™æµã€ç³»ç»Ÿä¿æŠ¤
3. **Gatewayå¢å¼º**: è‡ªå®šä¹‰è¿‡æ»¤å™¨ã€åŠ¨æ€è·¯ç”±

### ç¬¬ä¸‰é˜¶æ®µï¼šæ¶æ„ä¼˜åŒ– (1å‘¨)

1. **æ¶ˆæ¯é˜Ÿåˆ—**: Rediså¯é æ¶ˆæ¯é˜Ÿåˆ—
2. **ç›‘æ§å‘Šè­¦**: è‡ªå®šä¹‰æŒ‡æ ‡é‡‡é›†
3. **æ€§èƒ½è°ƒä¼˜**: è¿æ¥æ± ä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥

é€šè¿‡è¿™äº›æ·±åº¦åº”ç”¨ï¼ŒCloudDemoé¡¹ç›®å°†å±•ç°å‡ºå¯¹å¾®æœåŠ¡æŠ€æœ¯æ ˆçš„æ·±å…¥ç†è§£å’Œå®è·µèƒ½åŠ›ï¼Œä¸ºé¢è¯•åŠ åˆ†ä¸å°‘ã€‚
